<!DOCTYPE html>

<head>
  <link rel="stylesheet" href="./../notes_style.css">
  <style>
    body {
      font-family: 'Courier New', Courier, monospace;
      font-size: 18px;
      background-color: rgb(28, 28, 28);
      color: rgb(226, 234, 241);
    }

    .code {
      font-family: "Consolas";
      color: rgb(236, 255, 209);
      border: 1px;
      border-style: inset;
      width: 98%;
    }

    .con {
      background-color: black;
      border: 2px;
      border-style: double;
      padding: 3px;
      margin: 3px;
      width: 98%;

    }

    .comment {
      font-size: medium;
      font-style: italic;
      color: rgb(112, 111, 111);
    }

    h2 {
      color: rgb(72, 176, 245);
    }

    h4 {
      color: rgb(71, 144, 177);
      font-style: italic;
    }

    b {
      color: orange;
    }

    .keyword {
      color: rgb(13, 122, 255);
    }

    .fn {
      color: rgb(255, 16, 16);
    }
  </style>
</head>

<body>
  <div id="0" class="con">
    <h2>About JavaScript</h2>
    <b>ES6</b>
    <p>ES6, Which is also known as ECMAScript 2015, introduced some features in JavaScript language.</p>
    <ul>
      <li><b>Arrow Functions</b> : Arrow function {()=>} is concise way of writing JavaScript functions in shorter way.
        They
        make our code more structured and readable.
        <br>
        <div class="code">
          <code class="!whitespace-pre hljs language-javascript"><span class="hljs-comment">// ES5</span>
            <span class="hljs-keyword">var</span> add = <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) {
                <span class="hljs-keyword">return</span> a + b;
            };
            <span class="hljs-comment">// ES6</span>
            <span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;
            </code>
        </div>
      </li>
      <li><b>Let and Const Declarations</b>: let and const introduce block-scoped that provide better control over
        variable scope and preventing unintended reassignments.
        <div class="code">
          <code class="!whitespace-pre hljs language-javascript"><span class="hljs-comment">// ES5</span>
            <span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
                <span class="hljs-keyword">var</span> x = <span class="hljs-number">20</span>;
            }
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 20</span>
            
            <span class="hljs-comment">// ES6</span>
            <span class="hljs-keyword">let</span> y = <span class="hljs-number">10</span>;
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
                <span class="hljs-keyword">let</span> y = <span class="hljs-number">20</span>;
            }
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">// 10</span>
            </code>
        </div>
      </li>
      <li><b>Template Literals</b>: Template literals allow for easier string interpolation and multiline strings, using
        backticks.
        <div class="code">
          <code class="!whitespace-pre hljs language-javascript"><span class="hljs-comment">// ES5</span>
            <span class="hljs-keyword">var</span> name = <span class="hljs-string">"John"</span>;
            <span class="hljs-keyword">var</span> message = <span class="hljs-string">"Hello, "</span> + name + <span class="hljs-string">"!"</span>;
            <span class="hljs-comment">// ES6</span>
            <span class="hljs-keyword">let</span> name = <span class="hljs-string">"John"</span>;
            <span class="hljs-keyword">let</span> message = <span class="hljs-string">`Hello, <span class="hljs-subst">${name}</span>!`</span>;
            </code>
        </div>


      </li>
      <li><b>Default Parameters</b>: ES6 allows parameters to have default values if no argument is provided when the
        function is called.
        <div class="code">
          <code class="!whitespace-pre hljs language-javascript"><span class="hljs-comment">// ES6</span>
            <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name = <span class="hljs-string">'World'</span></span>) {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${name}</span>!`</span>);
            }
            <span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// Hello, World!</span>
            <span class="hljs-title function_">greet</span>(<span class="hljs-string">'Alice'</span>); <span class="hljs-comment">// Hello, Alice!</span>
            </code>
        </div>

      </li>
      <li><b>Spread and Rest Operators</b>: The spread operator (...) allows for the expansion of iterable objects into
        individual elements, while the rest operator collects multiple elements into a single array.
        <div class="code">
          <code class="!whitespace-pre hljs language-javascript"><span class="hljs-comment">// Spread operator</span>
          <span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
          <span class="hljs-keyword">let</span> arr2 = [...arr1, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
          
          <span class="hljs-comment">// Rest operator</span>
          <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...numbers</span>) {
              <span class="hljs-keyword">return</span> numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, num</span>) =&gt;</span> total + num, <span class="hljs-number">0</span>);
          }
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 15</span>
          </code>
        </div>
      </li>
      <li><b>Classes</b>: ES6 introduces class syntax for defining objects and inheritance hierarchies, which is
        syntactic sugar over JavaScript's existing prototype-based inheritance.
        <div class="code">
          <code class="!whitespace-pre hljs language-javascript"><span class="hljs-comment">// ES6</span>
          <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> {
              <span class="hljs-title function_">constructor</span>(<span class="hljs-params">width, height</span>) {
                  <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = width;
                  <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;
              }
              <span class="hljs-title function_">area</span>(<span class="hljs-params"></span>) {
                  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span>;
              }
          }
          </code>
        </div>
      </li>
    </ul>
  </div>
  <div id="100" class="con">
    <h2>JavaScript Engine</h2>
    <p>All modern browsers have their own version of the JavaScript Engine, like V8 in Chrome, SpiderMonkey in Firefox,
      or JavaScriptCore in Safari, they are responsible for executing JavaScript code.</p><br>
    <ul>
      <li>V8 - JavaScript Engine developed by Google for Chrome</li>
      <li>SpiderMonkey - The JavaScript Engine used by Mozilla Firefox</li>
      <li>JavaScriptCore - Developed by Apple for Safari</li>
      <li>Rhino - Managed by Mozilla Foundation for Firefox</li>
      <li>Chakra - A JavaScript Engine for Microsoft Edge</li>
      <li>JerryScript - A JavaScript Engine employed for the Internet of Things (IoT).</li>
    </ul>
    <br>

    1. <b>Parsing</b>: The engine starts by parsing the JavaScript code. It reads the code and
    generates a data structure called the Abstract Syntax Tree (AST), which represents the syntactic structure of the
    code.
    <br>
    2. <b>Compilation</b>: After parsing, the engine compiles the JavaScript code into bytecode or machine code, which
    browser can understand.
    <br>
    3. <b>Optimizations</b>: Modern JavaScript engines employ various optimization techniques to improve performance.
    These include inline caching, function inlining, loop unrolling, and dynamic optimization based on runtime feedback.
    Optimization is an ongoing process and may happen at different stages of execution.
    <br>
    4. <b>Execution</b>: Once the code is parsed and compiled, the engine executes it line by line. During execution,
    variables are allocated memory, functions are defined, and statements are executed sequentially. The engine also
    manages the call stack to keep track of function calls and their execution contexts. JavaScript is single-threaded
    and uses an event-driven, asynchronous programming model, meaning that certain operations like I/O operations or
    any asynchronous operations do not block the main execution thread.
    <br>
    5. <b>Event Loop</b>: JavaScript utilizes an event loop to manage asynchronous operations and handle events. The
    event loop continuously checks for tasks in the task queue and executes them in a first-in-first-out manner. This
    allows JavaScript to handle tasks such as responding to user interactions, fetching data from servers, or executing
    callbacks without blocking the main thread.
    <br>
    6. <b>Rendering</b>: JavaScript often interacts with the Document Object Model (DOM) to manipulate the structure and
    content of the web page dynamically. Changes made to the DOM through JavaScript can trigger reflows and repaints,
    ultimately updating what the user sees on the screen.
    <br><br>


    <b>Memory Heap</b>
    <p>Heap is a large unstructured data structure that stores all the dynamic data like function definitions, objects,
      arrays, etc. The memory heap is where the memory allocation happens, it is a location in memory where memory may
      be allocated at random access. Individual data elements distributed on the heap are typically released in ways
      that are asynchronous from one another. The memory occupied in the heap continues to exist even after JavaScript
      code execution has been completed and is later removed by the JavaScript Garbage Collector if needed.</p>


  </div>
  <div id="102" class="con">
    <h2>Ahead of Time (AOT)</h2>
    <p>When you serve/build your angular application, the Ahead of Time compiler converts your code during the build
      time before your browser downloads and runs that code.</p>
    <br>
    <p>Why should you use the Ahead of Time compiler ?</p>
    <ul>
      <li>- When you are using Ahead of Time Compiler, compilation only happens once, while you build your project.</li>
      <li>- The browser does not need to compile the code in run time, it can directly render the application
        immediately, without waiting to compile the app first so, it provides quicker component rendering.</li>
      <li>- We don't have to ship the HTML templates and the Angular compiler whenever we enter a new component.</li>
      <li>- It can minimize the size of your application.</li>
      <li>- The Ahead of time compiler detects template error earlier. It detects and reports template binding errors
        during the build steps before users can see them.</li>
      <li>- AOT provides better security, It reduces the chances of injections attacks, because it compiles HTML
        components and templates into JavaScript files long before they are served into the client display. So, there
        are no templates to read and no risky client-side HTML or JavaScript evaluation.</li>
    </ul>
  </div>

  <div id="103" class="con">
    <h2>Just in Time (JIT)</h2>
    <p>In Just in Time (JIT), code get compiles when it's needed, not at the build time.</p>
    <br>
    <p>Why and When Should you use Just In Time Compiler ?</p>
    <ul>
      <li>- In Just in Time (JIT), Most compiling is done on the browser side, so it will take less compiling time.</li>
      <li>- Just in time compiler compiles each file separately and it's mostly compiled in the browser. You don't have
        to
        build your project again after changing your code.</li>
      <li>- Just in Time compiler is best when your application is in local development.</li>
    </ul>
  </div>

  <div id="1" class="con">
    <h2>NodeJS</h2>
    Node.js is an open-source, server-side JavaScript runtime environment built on Chrome's V8 JavaScript engine. It
    allows you to execute JavaScript code on the server, which makes it ideal for building scalable and real-time
    applications.

  </div>

  <div id="2" class="con">
    <h2>Event loop</h2>
    The event loop is a core concept in JavaScript that allows the browser to handle asynchronous operations without
    blocking the main thread.
    The event loop works by constantly checking if there are any tasks in the queue and executing them one by one until
    the queue is empty.
    <h2>Microtasks Queue</h2>
    Asynchronous operations need proper management. For that, for that JavaScript has an internal queue also called as
    PromiseJobs more often referred to as the "microtask queue" (V8 term).
  </div>

  <div id="101" class="con">
    <h2>Macrotasks and Microtasks</h2>
    <br>
    <h4>Macrotasks:</h4>
    <p>
      Macrotasks are tasks that are scheduled to be executed in the main script execution context. They include
      operations like script execution, rendering, input events, setTimeout, setInterval, requestAnimationFrame, I/O
      operations, and UI rendering. Macrotasks are processed one at a time, in sequence.
    </p>
    <p><u>Examples of macrotasks</u>:</p>
    <ul>
      <li>- Script execution</li>
      <li>- setTimeout and setInterval callbacks</li>
      <li>- I/O operations</li>
      <li>- DOM rendering</li>
      <li>- UI rendering</li>
    </ul>
    <br>
    <h4>Microtasks:</h4>
    <p>
      Microtasks are tasks that are scheduled to be executed after the execution of the current task and before the next
      macrotask. They are usually high-priority tasks and are executed as soon as the call stack is empty. Microtasks
      are used for tasks that need to be processed quickly, such as promise resolution, mutation observer callbacks, and
      process.nextTick in Node.js.
    </p>
    <p><u>Examples of microtasks</u>:</p>
    <ul>
      <li>- Promise resolution (resolve or reject)</li>
      <li>- Mutation observer callbacks</li>
      <li>- process.nextTick in Node.js</li>
    </ul>

    <p><b>process.nextTick()</b> is a method that allows you to schedule a callback function to be invoked during the
      next iteration of the event loop, immediately after the current operation completes.</p>
    <br>
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript">
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Start'</span>);

    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Inside nextTick callback'</span>);
    });
        
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Inside setTimeout callback'</span>);
    }, <span class="hljs-number">0</span>);
        
    <span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Inside setImmediate callback'</span>);
    });
        
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'End'</span>);
    </code>
    </div>

    <h4>Relationship:</h4>
    <p>
      When a macrotask is executed, it can queue up microtasks, and those microtasks will be executed before the next
      macrotask is picked from the queue. This ensures that microtasks are executed as soon as possible after the
      current execution context is cleared.
    </p>
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript">
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Start'</span>);

        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'setTimeout (macrotask) executed'</span>);
        }, <span class="hljs-number">0</span>);
        
        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Promise (microtask) resolved'</span>);
        });
        
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'End'</span>);
        </code>
    </div>

    <p>Output:</p>

    <div class="code">
      <code class="!whitespace-pre hljs language-java">
        Start
        End
        <span class="hljs-title function_">Promise</span> <span class="hljs-params">(microtask)</span> resolved
        <span class="hljs-title function_">setTimeout</span> <span class="hljs-params">(macrotask)</span> executed
        </code>
    </div>
    <p>
      In this example, even though setTimeout is scheduled with a delay of 0 milliseconds, it is processed after the
      current execution context. On the other hand, the Promise microtask is executed before the setTimeout macrotask
      because microtasks have higher priority and are executed before the next macrotask.
    </p>






  </div>




  <div id="3" class="con">
    <h2>Cluster</h2>
    <ul>
      <li>The cluster module allows you to create multiple processes (that share the same server port).</li>
      <li>With clusters, you can create multi-core CPUs</li>
      <li>Cluster helps you to improve performance</li>
      <li> With cluster, you can handle concurrent requests.</li>
    </ul>
    <br>

    Here's how you can use the cluster module:<br>

    <div class="code"><code class="!whitespace-pre hljs language-javascript">
        <span class="hljs-keyword">const</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cluster'</span>);
        <span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
        <span class="hljs-keyword">const</span> numCPUs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'os'</span>).<span class="hljs-title function_">cpus</span>().<span class="hljs-property">length</span>;
        
        <span class="hljs-keyword">if</span> (cluster.<span class="hljs-property">isMaster</span>) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Master <span class="hljs-subst">${process.pid}</span> is running`</span>);
        
          <span class="hljs-comment">// Fork workers</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numCPUs; i++) {
            cluster.<span class="hljs-title function_">fork</span>();
          }
        
          cluster.<span class="hljs-title function_">on</span>(<span class="hljs-string">'exit'</span>, <span class="hljs-function">(<span class="hljs-params">worker, code, signal</span>) =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Worker <span class="hljs-subst">${worker.process.pid}</span> died`</span>);
          });
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// Workers can share any TCP connection</span>
          <span class="hljs-comment">// In this case it is an HTTP server</span>
          http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
            res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>);
            res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'Hello World\n'</span>);
          }).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>);
        
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Worker <span class="hljs-subst">${process.pid}</span> started`</span>);
        }
        </code>

    </div>
    <br>
    In this example:<br>
    <ul>
      <li>The master process (cluster.isMaster === true) forks child worker processes (cluster.fork()) equal to the
        number
        of available CPUs.</li>
      <li>Each worker process (cluster.isMaster === false) runs its own server, serving HTTP requests.</li>
      <li>If a worker dies or crashes, the master process receives an 'exit' event and can decide to fork a new worker
        to
        replace it.</li>
    </ul>
    Using the cluster module, you can achieve load balancing across multiple CPU cores, providing better concurrency and
    performance for your Node.js applications.
  </div>

  <div id="4" class="con">
    <h2>Worker Thread</h2>
    Worker threads are the separate thread which runs parallel with the main thread. They are used to perform
    CPU-intensive tasks. Worker threads can be particularly useful for parallelizing tasks and improving the performance
    of multi-core systems.

    <div class="code">
      <code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Worker</span>, isMainThread, parentPort } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);

        <span class="hljs-keyword">if</span> (isMainThread) {
          <span class="hljs-comment">// This code runs in the main thread (the main JavaScript file)</span>
        
          <span class="hljs-comment">// Create a new worker thread</span>
          <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(__filename);
        
          <span class="hljs-comment">// Listen for messages from the worker thread</span>
          worker.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Received message from worker:'</span>, message);
          });
        
          <span class="hljs-comment">// Send a message to the worker thread</span>
          worker.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">'Hello from the main thread'</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// This code runs in the worker thread</span>
        
          <span class="hljs-comment">// Listen for messages from the main thread</span>
          parentPort.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Received message from main thread:'</span>, message);
        
            <span class="hljs-comment">// Send a message back to the main thread</span>
            parentPort.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">'Hello from the worker thread'</span>);
          });
        }
        </code>

    </div>

  </div>

  <div id="5" class="con">
    <h2>Child process</h2>
    <ul>
      <li>The child process is a process that runs in parallel with the main process</li>
      <li>You can use the fork() method to create a child process.</li>
      <li>
        This fork() method creates a new process and establishes a connection with the main process.
      <li>Then there are 2 processes, the parent process, and the child process.</li>
      </li>
    </ul>

    <div class="code">
      const {fork} = require('child_process');<br>
      const child = fork('child.js');<br>
      <br>
      child.send('Hello from parent');<br>
      <br>
      child.on('message', (data)=>{<br>
      console.log(`Data received from Child ${data}`);<br>
      });<br>
      <span class="comment">//In Child.js</span>
      <br>
      process.on('message', (mgs)=>{<br>
      console.log(`Message received from parent ${msg}`);<br>
      });<br>

      process.send('Hello from child');<br>

    </div>

  </div>

  <div id="6" class="con">
    <h2>Stream</h2>
    <ul>
      <li>Stream is used to handle data in chunks rather than loading the entire dataset into memory. </li>
      <li>There are four types of streams in Node.js:<br>
        - Readable<br>
        - Writable<br>
        - Duplex<br>
        - Transform
      </li>
    </ul>


    <div class="code">
      const fs = require('fs');<br>
      <br>
      <span class="comment">// Creating a readable stream</span>
      <br>
      const readableStream = fs.createReadStream('input.txt', 'utf8');<br>
      <br>
      <br>
      <span class="comment">// Creating a writable stream</span>
      <br>
      const writableStream = fs.createWriteStream('output.txt');<br>
      <br>
      <span class="comment">// Pipe the readable stream to the writable stream</span>
      <br>
      readableStream.pipe(writableStream);<br>
      <span class="comment">// You can also listen for events on the streams</span>
      <br>
      readableStream.on('data', (chunk) => {<br>
      console.log(`Received ${chunk.length} bytes of data.`);<br>
      });<br>
      <br>
      readableStream.on('end', () => {<br>
      console.log('Finished reading the file.');<br>
      });<br>
      writableStream.on('finish', () => {<br>
      console.log('Finished writing to the file.');<br>
      });<br>
      <br>

    </div>

    We use the pipe method to pipe the data from the readable stream to the writable stream, effectively handling data
    in chunks.<br>
    <h4>Duplex Stream</h4>
    A duplex stream represents both a readable and a writable stream.<br>
    For example, a network socket can be considered a duplex stream where data can be both read from and written to the
    socket.<br>

    <h4>Transform Stream</h4>
    A transform stream is used to transform data.<br>
    Eg:<br>
    <li>Data compression</li>
    <li> Encryption etc</li>
  </div>

  <div id="7" class="con">
    <h2>Zlib</h2>
    Zlib library is used to compress and decompress streams eg: files, text files. You can use it to compress or
    decompress data using various compression algorithms such as deflate, gzip, and brotli.

    <h3>Compression</h3>
    <p>We're compressing the contents of the input.txt file using gzip compression and writing the compressed data to a
      file named compressed.gz.</p>
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zlib'</span>);
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
        
        <span class="hljs-keyword">const</span> inputFilePath = <span class="hljs-string">'input.txt'</span>;
        <span class="hljs-keyword">const</span> outputFilePath = <span class="hljs-string">'compressed.gz'</span>;
        
        <span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(inputFilePath);
        <span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(outputFilePath);
        
        <span class="hljs-keyword">const</span> gzip = zlib.<span class="hljs-title function_">createGzip</span>();
        
        readStream.<span class="hljs-title function_">pipe</span>(gzip).<span class="hljs-title function_">pipe</span>(writeStream);
        
        writeStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'finish'</span>, <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'File compressed successfully.'</span>);
        });
        </code>
    </div>
    <h3>Decompression</h3>
    <p>We're decompressing the contents of the compressed.gz file using gzip decompression and writing the decompressed
      data to a file named decompressed.txt.</p>
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zlib'</span>);
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
        
        <span class="hljs-keyword">const</span> inputFilePath = <span class="hljs-string">'compressed.gz'</span>;
        <span class="hljs-keyword">const</span> outputFilePath = <span class="hljs-string">'decompressed.txt'</span>;
        
        <span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(inputFilePath);
        <span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(outputFilePath);
        
        <span class="hljs-keyword">const</span> gunzip = zlib.<span class="hljs-title function_">createGunzip</span>();
        
        readStream.<span class="hljs-title function_">pipe</span>(gunzip).<span class="hljs-title function_">pipe</span>(writeStream);
        
        writeStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'finish'</span>, <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'File decompressed successfully.'</span>);
        });
        </code>
    </div>


  </div>

  <div id="8" class="con">
    <h2>Buffer class</h2>
    The Buffer class is useful when dealing with binary data while performing read-write operations on the file
    system.<br>
    <br>
    <h4>Creating Buffers:</h4>
    <p>You can create buffers using the Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() methods.</p>
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript"><span class="hljs-comment">// Creating buffer from a string</span>
        <span class="hljs-keyword">const</span> bufFromString = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello, World!'</span>);
        
        <span class="hljs-comment">// Creating buffer from an array</span>
        <span class="hljs-keyword">const</span> bufFromArray = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">0x68</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x6f</span>]); <span class="hljs-comment">// 'hello'</span>
        
        <span class="hljs-comment">// Creating buffer with a specific size</span>
        <span class="hljs-keyword">const</span> bufWithSize = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// Creates a buffer of size 10 with all bytes set to 0</span>
        
        <span class="hljs-comment">// Creating buffer with an uninitialized memory</span>
        <span class="hljs-keyword">const</span> uninitializedBuffer = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">allocUnsafe</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// Creates a buffer of size 10 without initializing it</span>
        </code>
    </div>
    <br>
    <h4>Reading and Writing Buffers:</h4>
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript"><span class="hljs-comment">// Reading from a buffer</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bufFromString.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// Outputs: Hello, World!</span>
        
        <span class="hljs-comment">// Writing to a buffer</span>
        <span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">5</span>);
        buf.<span class="hljs-title function_">write</span>(<span class="hljs-string">'Hello'</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'utf-8'</span>); <span class="hljs-comment">// Writes the string 'Hello' starting from index 0</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// Outputs: Hello</span>
        </code>
    </div>
    <br>
    <h4>Concatenating Buffers:</h4>
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript"><span class="hljs-comment">// Concatenating buffers</span>
        <span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello'</span>);
        <span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">' World'</span>);
        <span class="hljs-keyword">const</span> concatenatedBuf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>([buf1, buf2]);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(concatenatedBuf.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// Outputs: Hello World</span>
        </code>
    </div>
    <br>
    <h4>Manipulating Buffers:</h4>
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript"><span class="hljs-comment">// Slicing buffers</span>
    <span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello, World!'</span>);
    <span class="hljs-keyword">const</span> slicedBuf = buf.<span class="hljs-title function_">slice</span>(<span class="hljs-number">7</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">// Slice from index 7 to 11 (inclusive)</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(slicedBuf.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// Outputs: World</span>
    
    <span class="hljs-comment">// Modifying buffer</span>
    buf.<span class="hljs-title function_">write</span>(<span class="hljs-string">'Node.js'</span>, <span class="hljs-number">7</span>); <span class="hljs-comment">// Overwrite 'World' with 'Node.js'</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// Outputs: Hello, Node.js!</span>
    </code>
    </div>
    <br>
    <h4>Buffer Properties:</h4>
    Buffers have several properties like:
    <br>
    - <b>length</b>: The length of the buffer in bytes.<br>
    - <b>byteLength</b>: An alias for length.<br>
    - <b>byteOffset</b>: The offset of the buffer in the parent buffer.<br>
    - <b>buffer</b>: The underlying ArrayBuffer of the buffer.<br>
    <br>
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello, World!'</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-property">length</span>); <span class="hljs-comment">// Outputs: 13</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-property">byteLength</span>); <span class="hljs-comment">// Outputs: 13</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-property">byteOffset</span>); <span class="hljs-comment">// Outputs: 0</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-property">buffer</span>); <span class="hljs-comment">// Outputs: ArrayBuffer {...}</span>
        </code>
    </div>
  </div>

  <div id="9" class="con">
    <h2>Import v/s Require</h2>
    <ul>
      <li>Require is an inbuilt function that is used to include modules that exist in separate files. (It is CommonJS
        Syntax)
        <ol>- const http = require(‘http')</ol>
      </li>
      <li>The require() is synchronous, ie. it blocks other operations until the module is loaded.</li>
      <li>Import is the modern approach to include external modules.</li>
      <li>It was introduced in ES6 from Node version 12.
        <ol>- import test from ‘./test.js' </ol>
      </li>
    </ul>
    <div class="code">

    </div>

  </div>

  <div id="10" class="con">
    <h2>How NodeJS prevent blocking code?</h2>
    Node uses a single thread, which means one task can be executed at a time. This is done by using a stack. While
    reading the code from top to bottom, each instruction is pushed into a stack and when its execution is completed, it
    pops out of the stack. Events that take longer time to execute can result in a delay in popping the stack and
    execution of further statements. <br>
    <br>
    So what Node.js allows is the use of Event Loop. Each time when we encounter such a situation, the process causing
    the delay is offloaded from the stack and the execution of that process continues parallel to further execution of
    the main code. Thus, the callback for that function is pushed into a task queue and the code continues to execute
    asynchronously. When the process completes its execution, the callback function returns the desired output from that
    process and resumes normal execution.<br>

    <div class="code">

    </div>

  </div>

  <div id="11" class="con">
    <h2>SECURITY</h2>
    <ul>
      <li>Authentication</li>
      <li>Authorization</li>
      <li>Encryption and Hashing</li>
      <li>Helmet</li>
      <li>CORS</li>
      <li>CSRF Protection</li>
      <li>Rate limiting</li>
    </ul>

    <p><b>Authentication</b>: is when a user tries to login to the appication with the username and password. Once
      authenticated, the server will issue a JSON web token (JWT). So this token can be sent as a bearer token in an
      authorization header on subsequent requests for authentication.</p>
    <p><b>Authorization</b>: Authorization means a user who has logged to the the application can access some protected
      routes or no. Role based authorization is one example. <br>
      You can use <b>Guards</b> for role based authorization.
    <ul>
      <li>A guard is a class annoted with the '@'Injectable() decorator. Guards should implemement the CanActivate
        inerface.</li>
      <li>It stands between the client (user) and the route handler.</li>
      <li>It has a single responsibility. They determine whether a given request will be handled by the route handler or
        not, depending on certain conditions (like permission, roles ACLs etc.)</li>
    </ul>
    </p>

    <p><b>Encryption and Hashing</b>: Encryption is a process where you convert the sensative data into an alternative
      form and only an authorized party can Decrypt it. You can use crypto module to encrypt and decrypt the data.<br>
      For Hashing you can use bcrypt or argon2 modules.</p>

    <span class="comment">Encrypt the text 'abc'</span>
    <div class="code">
      var crypto = require('crypto');<br>
      <br>
      var mykey = crypto.createCipher('aes-128-cbc', 'mypassword');<br>
      var mystr = mykey.update('abc', 'utf8', 'hex')<br>
      mystr += mykey.final('hex');<br>
      <br>
      console.log(mystr); <span class="comment">//34feb914c099df25794bf9ccb85bea72</span><br>
    </div>
    <br>
    <span class="comment">Decrypt back to 'abc'</span>
    <div class="code">
      var crypto = require('crypto');<br>
      <br>
      var mykey = crypto.createDecipher('aes-128-cbc', 'mypassword');<br>
      var mystr = mykey.update('34feb914c099df25794bf9ccb85bea72', 'hex', 'utf8')<br>
      mystr += mykey.final('utf8');<br>

      console.log(mystr); <span class="comment">//abc</span>
    </div>


    <p><b>Helmet</b>: With helmet you can secure HTTP response headers. Each headers can be configured. By default,
      Helmet sets the following headers:</p>
    <ul>
      <li>X-Frame-Options: Legacy header that mitigates clickjacking attacks</li>
      <li>X-Content-Type-Options: Avoids MIME sniffing</li>
      <li>Cross-Origin-Resource-Policy: Blocks others from loading your resources cross-origin</li>
    </ul>

    <p><b>CORS</b>: Cross-origin resource sharing (CORS) is a mechanism that allows resources to be requested from
      another domain.</p>

    <p><b>CSRF Protection</b>: Cross Site Request Forgery (CSRF) is one of the most severe vulnerabilities which can be
      exploited in various ways - from changing user's info without his knowledge to gaining full access to user's
      account.
    </p>















    When we build a NestJS application in the backend, we usually separate our logic into controllers and services.
    Controllers are responsible for handling incoming requests and returning responses for the clients, and services are
    responsible for executing the business logic.

    <h4>Use Code Reviews to Identify Potential Security Threats: </h4>
    <ul>
      <li>Peer reviews</li>
      <li>Test your code and write unit tests for all areas of concern.</li>
    </ul>
    <h4>Use Static Code Analysis Tools - Eg Sonarqube</h4>
    <ul>
      <li> Before your software is deployed, static code analysis tools are an excellent approach to finding software
        vulnerabilities. It can be integrated into the pipeline so that every time there is a new build, and it will
        automatically run through these checks and flag any potential issues.</li>
    </ul>

    <br>
    Follow standard coding guidelines<br>
    <h4>Encryption:</h4>
    <ul>
      <li> Encryption is the only way to maintain the confidentiality of user data on a network where any node can
        potentially become compromised by an attacker who will have full access to all traffic they observe.</li>
    </ul>


    <h4>Password Hashing -</h4>
    <ul>
      <li>Use a password hashing algorithm to compute a unique hash of the user's password that can be stored in your
        database.</li>
      <li>Eg: Password Hashing with a Crypto module</li>
    </ul>
    <h4>SQL Injection</h4>
    <ul>
      <li>SQL injection attack is when a hacker inserts a SQL query through an application interface to extract or
        manipulate data from the back-end database.</li>
      <li>SQL injection attacks can be prevented by using parameterized queries instead of dynamic SQL statements.</li>

    </ul>

    <h4> Cross-Site Scripting (XSS)</h4>
    <ul>
      <li> XSS is a type of attack that occurs when an attacker injects malicious scripts into the application. This
        kind
        of attack aims to get users to click on links that will then send them to malicious sites.</li>
    </ul>


    <h4>Input Validation Attacks</h4>
    <li>Input validation attacks are when an attacker finds a way to manipulate the application into accepting data that
      it shouldn't.</li>
  </div>

  <div id="12" class="con">
    <h2>System Design</h2>
    Plan of Action:<br>
    <li>Requirements and Goals of the System</li>
    - Scope the problem<br>
    - Functional Requirements<br>
    - Non-functional requirements<br>
    <li>High-level Design</li>
    - Discuss the components<br>
    - How components fit together<br>
    <li>Detailed Design</li>
    - Data Modeling<br>
    - Exception Handling<br>
    - Parallel Computing<br>
    - Distributed Environment<br>

    <p>System design consists of various aspects such as architecture design, database design, networking, security,
      scalability, and performance optimization. Here's an overview of the key components involved in system design:</p>
    <br>
    <b>Requirements Analysis</b>: Understanding the needs and constraints of the system stakeholders is the first step.
    This involves gathering requirements, defining use cases, and identifying non-functional requirements such as
    scalability, reliability, and performance.
    <br><br>
    <b>Architecture Design</b>: This involves defining the high-level structure of the system, including
    components/modules, their interactions, and the overall system behavior. Common architectural patterns include
    client-server, microservices, event-driven, and layered architectures.
    <br><br>
    <b>Database Design</b>: Designing the data storage and retrieval mechanisms based on the requirements. This includes
    choosing appropriate database technologies, defining schemas, and optimizing data access patterns for efficiency.
    <br><br>
    <b>Networking</b>: Designing the communication infrastructure that enables interaction between different components
    of the system. This includes protocols, data formats, and considerations for security and performance.
    <br><br>
    <b>Scalability and Performance</b>: Designing the system to handle increasing loads by scaling horizontally or
    vertically. This involves techniques such as load balancing, caching, and optimizing algorithms and data structures
    for performance.
    <br><br>
    <b>Security</b>: Implementing measures to protect the system from unauthorized access, data breaches, and other
    security threats. This includes authentication, authorization, encryption, and secure communication protocols.
    <br><br>
    <b>Fault Tolerance and Reliability</b>: Designing the system to continue functioning in the presence of failures or
    unexpected events. This involves techniques such as redundancy, replication, and graceful degradation.
    <br><br>
    <b>Monitoring and Logging</b>: Implementing mechanisms to monitor the health and performance of the system in
    real-time and to log relevant events for troubleshooting and analysis.
    <br><br>
    <b>Deployment and Operations</b>: Planning the deployment strategy for the system, including considerations for
    infrastructure provisioning, configuration management, and continuous integration/continuous deployment (CI/CD)
    pipelines.
    <br><br>
    <b>Documentation and Communication</b>: Documenting the design decisions, architectural diagrams, and operational
    procedures to facilitate collaboration among team members and to onboard new developers.
    <br><br>
    <p>
      System design is an iterative process that involves continuous refinement and improvement based on feedback and
      evolving requirements. It requires a deep understanding of both technical concepts and business objectives to
      design
      systems that effectively meet the needs of the users and the organization.</p>
  </div>

  <div id="13" class="con">
    <h2>API Security testing</h2>
    You can do:

    <h4>Functional testing</h4>
    Functional testing is the testing of specific functions within the codebase. It makes sure the API works within the
    expected parameters like,
    <uL>
      <li>returns the expected output for a particular request sent to the server</li>
      <li>How the API handles the errors when the results are outside of the expected parameters.</li>
      <li>You can do negative testing with invalid requests and check how your API handles those requests, whether it is
        throwing appropriate errors or not.</li>
    </uL>
    <h4>Performance testing</h4>
    In performance testing, you ensure that the API remains functional and reliable under higher load.

  </div>
  <div id="14" class="con">
    <h2>Kafka</h2>
    Apache Kafka is an open-source, distributed, pub-sub messaging system, written in Scala and Java.
    You can send asynchronous communications in the form of the stream to the Kafka cluster.

    <h4>Terminology</h4>
    <ul>
      <li>Producer - An application that sends messages to Kafka</li>
      <li>Consumer - An application that receives data/messages from Kafka</li>
      <li>Broker - Kafka server</li>
      <li>Cluster - Group of computers</li>
      <li>Topic - A name for a Kafka stream</li>
      <li>Partitions - Part of a topic</li>
      <li>Offset - Unique id for a message within a partition</li>
      <li>Consumer groups - A group of consumers acting as a single logical unit</li>
    </ul>

    <h4>Cluster</h4>
    In distributed systems a cluster is a group of computers working togethe for a common purpose.
    Topic: A topic is a unique name for a data stream.

    <h4>Partition</h4>
    The broker stores data for a topic, this data can be huge, it can be larger than the storing capacity of
    a single computer. So we can break that data into 2 or more parts and distribute it on multiple computers. Kafta is
    a distributed system that runs on a cluster of computers. Kafka does not know how many partitions to create it's up
    to us, we have to make that decision. When we create a topic we take that decision and Kafka broker will create that
    many partitions for your topic. Every partition sits on a single machine, you cannot break it again, so do some
    estimation and simple math to calculate the number of partitions.
    <h4>Offset</h4>
    A sequence number given to the messages as they arrive in a partition. They are unique and do not change.
    Offsets are local to the partition.

    To locate a message you need three things:
    <ul>
      <li>Topic name</li>
      <li>Partition number</li>
      <li>Offset</li>
    </ul>




    Partitioning and Consumer group is a tool for scalability.
    The maximum number of consumers in a group is the total number of partitions you have on the topic. Kafka does not
    allow more then two consumer to read form the same partition simultaneously, this restriction is necessary to avoid
    double reading of the records.





    <div class="code">

    </div>

  </div>

  <div id="15" class="con">
    <h2>Crypto</h2>

  </div>


  <div id="16" class="con">
    <h2>Express JS</h2>
    Express is a routing and middleware web framework. An Express application is essentially a series of middleware
    function calls.
    <ul>
      <li>Npm init -y → creates package.json file</li>
      <li>Npm i express</li>
      <li>npm i --save dev nodemon</li><span class="comment">//In package.json -> Inside scripts - >devStart": "nodemon
        server.js"</span>
      <li>Npm i ejs </li><span class="comment">//view engine to render files</span>
    </ul>
  </div>


  <div id="17" class="con">
    <h2>Middleware</h2>
    Middleware are functions that have access to the request object (req), the response object (res), and the next
    function in the application's request-response cycle. <br>
    <br>
    The next function is a function in the Express router which, when invoked, executes the middleware succeeding the
    current middleware.<br>
    <br>
    To load the middleware function, call app.use(), specifying the middleware function. <br>

    <ul>
      <li>app.use(myLogger)</li>
    </ul>
    <br>

    If the current middleware function does not end the request-response cycle, it must call next() to pass control to
    the next middleware function. Otherwise, the request will be left hanging. Eg:<br>

    <div class="code">
      const myLogger = function (req, res, next) {<br>
      console.log('LOGGED');<br>
      next();<br>
    </div>
    <br><i>
      Notice the call above to next(). Calling this function invokes the next middleware function in the app. The next()
      function is not a part of the Node.js or Express API, but is the third argument that is passed to the middleware
      function. The next() function could be named anything, but by convention, it is always named “next”. To avoid
      confusion, always use this convention.</i>
    <h4>Using Middleware</h4>
    Middleware functions can perform the following tasks:
    <ul>
      <li>Execute any code.</li>
      <li>Make changes to the request and the response objects.</li>
      <li>End the request-response cycle.</li>
      <li>Call the next middleware function in the stack.</li>
    </ul>
  </div>


  <div id="18" class="con">
    <h2>Types of Middlewares</h2>
    <ul>
      <li>Application-level middleware</li>
      <li>Router-level middleware</li>
      <li>Error-handling middleware</li>
      <li>Built-in middleware</li>
      <li>Third-party middleware</li>
    </ul>

    <h4>Application-level middleware</h4>
    Application-level middleware binds to app Object by using the app.use() and app.METHOD() functions, where METHOD is
    the HTTP method of the request that the middleware function handles (such as GET, PUT, or POST).<br>
    <br>
    <div class="code">
      const express = require('express');<br>
      const app = express();<br>
      <br>
      app.use((req, res, next) => {<br>
      console.log('Time:', Date.now())<br>
      next();<br>
      })<br>


    </div>
    <h4>Router-level middleware</h4>
    Router-level middleware works in the same way as application-level middleware, except it is bound to an instance of
    express.Router().<br>
    <br>

    <div class="code">
      const express = require('express');<br>
      const router = express.Router();<br>
      router.get('/user/:id', (req, res, next) => {<br>
      console.log(req.params.id)<br>
      res.render('special')<br>
      })<br>
      <br>
    </div>
    <h4>Error-handling middleware</h4>
    Error-handling middleware functions in the same way as other middleware functions, except with four arguments
    instead of three, specifically with the signature (err, req, res, next)<br>
    <br>
    <div class="code">
      app.use((err, req, res, next) => {<br>
      console.error(err.stack);<br>
      res.status(500).send('Something broke!')<br>
      })<br>
      <br>
    </div>
    <h4>Built-in middleware</h4>
    Express has the following built-in middleware functions:
    <ul>
      <li>express.static serves static assets such as HTML files, images, and so on.</li>
      <li>express.json parses incoming requests with JSON payloads.</li>
      <li>express.urlencoded parses incoming requests with URL-encoded payloads.</li>
    </ul>

    <h4>Third-party middleware</h4>

    <ul>
      <li>Body-parser</li>
      <li>Cors</li>
      <li>Multer </li>
      <li>Cookie-parser</li>
    </ul>

    <div class="code">
      <span class="comment">// Parse incoming request bodies in a middleware before your handlers, available under the
        req.body property.</span><br>

      const bodyParser = require('body-parser');<br>
      app.use(bodyParser.json())<br>
      <br>
      <span class="comment"> // Enable cross-origin resource sharing (CORS) with various options.</span><br>

      const cors = require('cors');<br>
      app.use(cors());<br>
      <span class="comment">//Multer - Handle multi-part form data.<br>
        //Multer is used for uploading files<br>
        //form action="/profile" method="post" enctype="multipart/form-data"//<br>
        //form//</span><br>

      const multer = require('multer');<br>
      const upload = multer({ dest: 'uploads/' });<br>
      app.post('/profile', upload.single('avatar'), function (req, res, next) { <br>
      <span class="comment">// req.file is the `avatar` file </span><br>
      })<br>

    </div>

  </div>


  <div id="19" class="con">
    <h2>Template engines</h2>
    A template engine enables you to use static template files in your application. At runtime, the template engine
    replaces variables in a template file with actual values and transforms the template into an HTML file sent to the
    client.<br><br>

    <div class="code">
      app.set('view engine', 'ejs');<br>
      app.get('/', (req, res, next)=>{<br>
      res.render('index', {text: "Hello World!!"})<br>
      })<br>
    </div>

    <ul>
      <li>To pass information from the server down into the views, the render function takes the second parameter as an
        object. res.render('index', {text: "Hello World!!"})</li>
      <li>Inside view.ejs file.<span class="comment"> //%= local.text % </span></li>
    </ul>

  </div>


  <div id="20" class="con">
    <h2>Process Manager</h2>

    When you run Express apps for production, it is helpful to use a process manager to:
    <ul>
      <li>Restart the app automatically if it crashes.</li>
      <li>Gain insights into runtime performance and resource consumption.</li>
      <li>Modify settings dynamically to improve performance.</li>
      <li>Control clustering.</li>
    </ul>
    <br>
    A process manager is somewhat like an application server: it's a "container" for applications that facilitates
    deployment, provides high availability, and enables you to manage the application at runtime.<br><br>
    The most popular process managers for Express and other Node.js applications are:<br>
    <ul>
      <li> Forever: A simple command-line interface tool to ensure that a script runs continuously (forever). Forever's
        simple interface makes it ideal for running smaller deployments of Node.js apps and scripts.</li>
      <li>PM2: A production process manager for Node.js applications that has a built-in load balancer. PM2 enables you
        to keep applications alive forever, reloads them without downtime, helps you to manage application logging,
        monitoring, and clustering.</li>
      <li>StrongLoop Process Manager (Strong-PM): A production process manager for Node.js applications with built-in
        load balancing, monitoring, and multi-host deployment. Includes a CLI to build, package, and deploy Node.js
        applications to a local or remote system.</li>
    </ul>

  </div>
  <div id="21" class="con">
    <h2>Security Best Practices</h2>
    Most of the time older versions are not maintained, so it's better to migrate to the latest version.<br>
    <br>
    If you are dealing with sensitive data, it is better to use SSL, This technology encrypts data before it is sent
    from the client to the server, thus preventing some common hacks like packet sniffing. TLS is the next level of SSL.
    <br><br>
    Packet sniffing is the process of intercepting the data stream that flows across the network, you can capture each
    packet and, if needed, decode the packet's raw data. This way you can get access to the raw value.
    <br><br>
    You can use Helmet. Helmet helps protect your application by setting HTTP headers appropriately.
    <br><br>
    <ul>
      <li>Content-Security-Policy header. This helps prevent cross-site scripting attacks.</li>
      <li>X-Frame-Options header. This provides clickjacking protection.</li>
      <li> Strict-Transport-Security header. This helps enforce secure (HTTPS) connections to the server.</li>
    </ul>
    <br>

    <b>Clickjacking</b> - When an attacker uses multiple transparent or opaque layers to trick a user into clicking on a
    button
    or link on another page.
    <br><br>
    Helmet is a collection of smaller middleware functions that set security-related HTTP response headers.
    <br><br>
    Security best practices for Express applications in production include:
    <ul>
      <li>Don't use deprecated or vulnerable versions of Express</li>
      <li>Use TLS (Transport Layer Security)</li>
      <li>Use Helmet</li>
      <li>Use cookies securely</li>
      <li>Prevent brute-force attacks against authorization</li>
      <li>Ensure your dependencies are secure</li>
      <li>Avoid other known vulnerabilities</li>
    </ul>
  </div>

  <div id="22" class="con">
    <h2>Performance best practices</h2>
    For performance best practices there are some things you can do with development and some things you have to do in
    your environment/setups.<br><br>

    <u>Things to do while development</u>:

    <h4>Handle exceptions properly</h4>
    So during development, you see that you are doing proper error handling in your code, and uncaught exceptions might
    crash your application, to avoid crashing see that you do proper exception handling. <br>

    You can use Promises, and try-catch blocks to catch errors.<br>

    <h4>error-first callbacks</h4>

    In Node/Express you can do error handling by using error-first callbacks. It is a convention for returning errors
    from asynchronous functions, where the first parameter to the callback function is the error object, followed by
    result data in succeeding parameters. <br><br>

    To indicate no error, pass null as the first parameter. <br><br>

    The best practice is to use the next() function to propagate errors through the middleware chain.<br>

    <h4>Implement Logs</h4>
    You can use the logging library to log all the activities. Eg: Winston<br>

    <h4>Avoid synchronous functions</h4>The synchronous function takes milliseconds to execute, if there is high traffic
    then these synchronous functions might reduce the performance.<br>

    <u>Things to do in Env - setup</u>:

    <ul>
      <li>Set NODE_ENV to "production"</li>
      <li>Ensure your app automatically restarts</li>
      <li>Run your app in a cluster</li>
      <li>Cache request results - Use Redis </li>
      <li>Use a load balancer</li>
      <li>Use a reverse proxy</li>
    </ul>

    In production, you can set NODE_ENV using Upstart. <br>
    With Upstart, use the env keyword in your job file. For example: # /etc/init/env.conf<br>
    <div class="code">env NODE_ENV=production</div>
    <br>
    Upstart is a system tool available on many Linux distributions for starting tasks and services during system
    startup, stopping them during shutdown, and supervising them. You can configure your Express app or process manager
    as a service and then Upstart will automatically restart it when it crashes.
    <br> <br>
    In development, you set environment variables in your interactive shell, by using export or your .bash_profile file.
    <br> <br>

    <b>Ensure your app automatically restarts</b>
    <ul>
      <li>Using a process manager to restart the app (and Node) when it crashes.</li>
      <li>Use the init system provided by your OS to restart the process manager when the OS crashes. It's also possible
        to use the init system without a process manager.</li>
    </ul>
  </div>


  <div id="23" class="con">
    <h2>WebSockets</h2>
    WebSockets provide a bidirectional communication channel between a client (such as a web browser) and a server. This
    allows real-time data transfer without the overhead of traditional HTTP requests and responses.<br><br>

    <b>Server-Side (Node.js)</b>
    <p>First, you need to set up a WebSocket server using Node.js. You can use the ws library, which provides a
      WebSocket implementation for Node.js:</p>

    <div class="code">
      <span class="comment">// server.js</span><br>
      <span class="keyword">const</span> <span class="fn">WebSocket</span> = require('ws');<br>
      <span class="keyword">const</span> wss = new <span class="fn">WebSocket.Server</span>({ port: 8080 });<br>
      <br>
      wss.<span class="fn">on</span>('connection', <span class="fn">function</span> <span
        class="fn">connection</span>(ws) {<br>
      console.log('A new client connected.');<br>
      <br>
      ws.<span class="fn">on</span>('message', <span class="fn">function</span> <span
        class="fn">incoming</span>(message) {<br>
      console.log('Received: %s', message);<br>
      <span class="comment">// Echo the received message back to the client</span><br>
      ws.<span class="fn">send</span>(`Server received: ${message}`);<br>
      });<br>
      });<br>
    </div>

    <b>Client-Side (JavaScript)</b>
    <p>Then, on the client-side, you can establish a WebSocket connection using JavaScript. Browser clients must use the
      native WebSocket object.</p>

    <div class="code">
      script><br>
      const ws = new WebSocket('ws://localhost:8080');<br>
      <br>
      <span class="comment">// Create WebSocket connection.</span><br>
      const socket = new WebSocket("ws://localhost:8080");
      <br><br>
      <span class="comment">// Connection opened</span><br>
      socket.addEventListener("open", (event) => {<br>
      socket.send("Hello Server!");<br>
      });<br>
      <br>
      <span class="comment">// Listen for messages</span><br>
      socket.addEventListener("message", (event) => {<br>
      console.log("Message from server ", event.data);<br>
      });<br>
      <br>
      /script><br>

      <p>
        <b>Instance methods:</b>
      <ul>
        <li>close()</li>
        <li>send()</li>
      </ul>
      <b>Events:</b>
      <ul>
        <li>close</li>
        <li>error</li>
        <li>message</li>
        <li>open</li>
      </ul>
      </p>
    </div>
  </div>

  <div id="24" class="con">
    <h2>Unhandled rejection</h2>
    An "unhandled rejection" occurs when a promise error is not handled at the end of the microtask queue. if we expect
    an error, we add .catch to the promise chain to handle it.
  </div>

  <div id="25" class="con">
    <h2>Promise</h2>
    Promise in JavaScript is object which represents the eventual completion (or failure) of an asynchronous operations.
    A Promise take two parameters: 'resolve' and 'reject'.

    <div class="code">
      <span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span
        class="fn">Promise</span>((resolve, reject) => {<br>
      <span class="comment">// Asynchronous operation, e.g., fetching data from an API</span><br>
      setTimeout(() => {<br>
      <span class="comment">// If operation is successful</span><br>
      <span class="keyword">resolve</span>('Data successfully fetched');<br>
      <span class="comment">// If operation fails</span><br>
      <span class="keyword">reject</span>('Failed to fetch data');<br>
      }, 2000);<br>
      });<br>

      <h2>Promise.all()</h2>
      <p>Promise.all() is useful for aggregating the results of multiple promises. It will reject immediately upon any
        of
        the input promise is rejected</p>

      <h2>Promise.allSettled()</h2>
      <p>Promise.allSettled() is typically used when you have multiple asynchronous tasks that are not dependent on one
        another to complete successfully, or you'd always like to know the result of each promise.</p>

      <h2>Promise.any()</h2>
      <p>Promise.any() is useful for returning the first promise that fulfills. It does not wait for the other promises
        to
        complete once it finds one.</p>

      <h2>Promise.race()</h2>
      <p>Promise.race() is useful when you want the first async task to complete, but do not care about its eventual
        state.</p>
    </div>
    <br>
    <h2>Nested Promise - Promise Chaining</h2>
    <p>Nested promises, also known as chained promises, are a common pattern in JavaScript for handling asynchronous
      operations in a sequential manner. Instead of nesting multiple levels of callbacks, which can lead to callback
      hell and reduce code readability, you can chain promises together to handle asynchronous operations more cleanly.
    </p>
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript">
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncOperation1</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'Async Operation 1 Completed'</span>);
            }, <span class="hljs-number">1000</span>);
        });
    }
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncOperation2</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'Async Operation 2 Completed'</span>);
            }, <span class="hljs-number">1000</span>);
        });
    }
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncOperation3</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'Async Operation 3 Completed'</span>);
            }, <span class="hljs-number">1000</span>);
        });
    }
    
    <span class="hljs-title function_">asyncOperation1</span>()
        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result1</span> =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1);
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">asyncOperation2</span>();
        })
        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result2</span> =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result2);
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">asyncOperation3</span>();
        })
        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result3</span> =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result3);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'All async operations completed successfully'</span>);
        })
        .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error:'</span>, error);
        });
    </code>
    </div>
    <br>
    <h2>Async-Await</h2>
    <p>Async-Await is a new JavaScript feature that allows you to write asynchronous code in a synchronous-like
      manner. It's provides cleaner and readable syntax for handling asynchronous operations.</p>

    <div class="code">
      <span class="keyword">async</span> <span class="fn">function</span> fetchData() {<br>
      try {<br>
      const data = <span class="keyword">await</span> fetchDataFromAPI(); <span class="comment">// fetchDataFromAPI()
        returns a promise</span><br>
      console.log(data);<br>
      } catch (error) {<br>
      console.error(error); <span class="comment">// Handle error</span><br>
      }<br>
      }<br>

      <br>
      <span class="fn">fetchData</span>()<br>
      . <span class="fn">then</span>((_data) => console.log('Data fetched successfully', _data))<br>
      . <span class="fn">catch</span>((error) => console.error('Failed to fetch data:', error));<br>


    </div>
  </div>

  <div id="26" class="con">
    <h2>Authentication and Authorization</h2>
    <p>Authentication is when you verify the user's identity using username and password during login, while
      authorization
      determines
      whether a user is authorised to perform actions in the application.</p>
    <p>You can use JWT token for stateless authentication. JWT token consists of user information like userId, roleId
      etc.<br>
      JWT (JSON Web Token) is a compact, URL-safe means of representing claims to be transferred between two parties.
      It's a JSON-based open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting
      information between parties as a JSON object. Here's a detailed breakdown of JWT:</p>
    <br>
    <b>Components of JWT</b>
    <br>
    1. <b>Header</b>: The header typically consists of two parts: the type of token (JWT) and the signing algorithm
    being used, such as HMAC SHA256 or RSA.<br>

    <div class="code">
      <code class="!whitespace-pre hljs language-json"><span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"alg"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"HS256"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"typ"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"JWT"</span>
        <span class="hljs-punctuation">}</span>
        </code>
    </div><br>

    2. <b>Payload (Claims)</b>: The payload contains data related to the user, Eg, userId, roleId etc.
    <div class="code">
      <code class="!whitespace-pre hljs language-json"><span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"sub"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1234567890"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"John Doe"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"admin"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
      <span class="hljs-punctuation">}</span>
      </code>
    </div><br>

    3. <b>Signature</b>: The signature is created by combining the encoded header, encoded payload, and a secret key (or
    private key in the case of RSA). The signature is used to verify the JWT.
    <div class="code">
      <code class="!whitespace-pre hljs language-scss"><span class="hljs-built_in">HMACSHA256</span>(
        base64UrlEncode(header) + "." +
        <span class="hljs-built_in">base64UrlEncode</span>(payload),
        secret
      )
      </code>
    </div>
  </div>

  <div id="27" class="con">
    <h2>Unit testing - Mocha-Chai</h2>
    An "unhandled rejection" occurs when a promise error is not handled at the end of the microtask queue. if we expect
    an error, we add .catch to the promise chain to handle it.

    <div class="code">
      <span class="comment">// utils.js</span><br>
      <span class="keyword">function</span> <span class="fn">sum</span>(a, b) {<br>
      <span class="keyword">return</span> a + b;<br>
      }<br>
      <br>
      module.exports = { sum };

    </div>
    <div class="code">
      <span class="comment">// test/utils.test.js</span><br>
      <span class="keyword">const</span> { expect } = <span class="keyword">require</span>('chai');<br>
      <span class="keyword">const</span> { sum } = <span class="keyword">require</span>('../utils');<br>
      <br>
      <span class="fn">describe</span>('sum function', () => {<br>
      <span class="fn">it</span>('should return the sum of two numbers', () => {<br>
      <span class="fn">expect</span>(sum(1, 2)).to.equal(3);<br>
      });<br>
      <br>
      <span class="fn">it</span>('should return 0 when adding -1 and 1', () => {<br>
      <span class="fn">expect</span>(sum(-1, 1)).to.equal(0);<br>
      });<br>
      });<br>

    </div>
  </div>

  <div id="28" class="con">
    <h2>Upload Image on AWS-S3</h2>
    <p>Create a file (uploadToS3.js) and add the following code:</p>
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">AWS</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'aws-sdk'</span>);
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
        
        <span class="hljs-comment">// Update the following variables with your S3 bucket name and desired key (file name) in S3</span>
        <span class="hljs-keyword">const</span> bucketName = <span class="hljs-string">'your-s3-bucket-name'</span>;
        <span class="hljs-keyword">const</span> key = <span class="hljs-string">'your-image-file-name.jpg'</span>; <span class="hljs-comment">// Change the file name and extension as needed</span>
        
        <span class="hljs-comment">// Set up AWS credentials and S3 client</span>
        <span class="hljs-variable constant_">AWS</span>.<span class="hljs-property">config</span>.<span class="hljs-title function_">update</span>({
          <span class="hljs-attr">accessKeyId</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">AWS_ACCESS_KEY_ID</span>,
          <span class="hljs-attr">secretAccessKey</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">AWS_SECRET_ACCESS_KEY</span>,
          <span class="hljs-attr">region</span>: <span class="hljs-string">'your-aws-region'</span>, <span class="hljs-comment">// Update with your AWS region</span>
        });
        
        <span class="hljs-keyword">const</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">AWS</span>.<span class="hljs-title function_">S3</span>();
        
        <span class="hljs-comment">// Read the image file as a buffer</span>
        <span class="hljs-keyword">const</span> fileContent = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'path/to/your/image.jpg'</span>); <span class="hljs-comment">// Update with the path to your image file</span>
        
        <span class="hljs-comment">// Set up the parameters for S3 upload</span>
        <span class="hljs-keyword">const</span> params = {
          <span class="hljs-title class_">Bucket</span>: bucketName,
          <span class="hljs-title class_">Key</span>: key,
          <span class="hljs-title class_">Body</span>: fileContent,
          <span class="hljs-title class_">ContentType</span>: <span class="hljs-string">'image/jpeg'</span>, <span class="hljs-comment">// Change the content type based on your file type</span>
          <span class="hljs-attr">ACL</span>: <span class="hljs-string">'public-read'</span>, <span class="hljs-comment">// Adjust the ACL based on your requirements</span>
        };
        
        <span class="hljs-comment">// Upload the file to S3</span>
        s3.<span class="hljs-title function_">upload</span>(params, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (err) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error uploading to S3:'</span>, err);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Successfully uploaded to S3:'</span>, data.<span class="hljs-property">Location</span>);
          }
        });
        </code>
    </div>
  </div>

  <div id="29" class="con">
    <h2>RabbitMQ</h2>
    <b>Let's create a producer and a consumer:</b>
    <h4>Producer</h4>
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> amqp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'amqplib'</span>);

        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">produceMessage</span>(<span class="hljs-params"></span>) {
          <span class="hljs-comment">// Connect to RabbitMQ server</span>
          <span class="hljs-keyword">const</span> connection = <span class="hljs-keyword">await</span> amqp.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'amqp://localhost'</span>);
          <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">createChannel</span>();
        
          <span class="hljs-comment">// Declare a queue</span>
          <span class="hljs-keyword">const</span> queueName = <span class="hljs-string">'hello'</span>;
          <span class="hljs-keyword">await</span> channel.<span class="hljs-title function_">assertQueue</span>(queueName, { <span class="hljs-attr">durable</span>: <span class="hljs-literal">false</span> });
        
          <span class="hljs-comment">// Send a message to the queue</span>
          <span class="hljs-keyword">const</span> message = <span class="hljs-string">'Hello RabbitMQ!'</span>;
          channel.<span class="hljs-title function_">sendToQueue</span>(queueName, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(message));
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Message sent: <span class="hljs-subst">${message}</span>`</span>);
        
          <span class="hljs-comment">// Close connection and channel</span>
          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            connection.<span class="hljs-title function_">close</span>();
            process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">0</span>);
          }, <span class="hljs-number">500</span>);
        }
        
        <span class="hljs-title function_">produceMessage</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);
        </code>
    </div>
    <h4>Consumer</h4>
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> amqp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'amqplib'</span>);

        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">consumeMessage</span>(<span class="hljs-params"></span>) {
          <span class="hljs-comment">// Connect to RabbitMQ server</span>
          <span class="hljs-keyword">const</span> connection = <span class="hljs-keyword">await</span> amqp.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'amqp://localhost'</span>);
          <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">createChannel</span>();
        
          <span class="hljs-comment">// Declare a queue</span>
          <span class="hljs-keyword">const</span> queueName = <span class="hljs-string">'hello'</span>;
          <span class="hljs-keyword">await</span> channel.<span class="hljs-title function_">assertQueue</span>(queueName, { <span class="hljs-attr">durable</span>: <span class="hljs-literal">false</span> });
        
          <span class="hljs-comment">// Consume messages from the queue</span>
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Waiting for messages...'</span>);
          channel.<span class="hljs-title function_">consume</span>(queueName, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span> (message !== <span class="hljs-literal">null</span>) {
              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received message: <span class="hljs-subst">${message.content.toString()}</span>`</span>);
              channel.<span class="hljs-title function_">ack</span>(message); <span class="hljs-comment">// Acknowledge message</span>
            }
          });
        
          <span class="hljs-comment">// Close connection and channel</span>
          <span class="hljs-comment">// This should not be reached, as the consumer will keep running</span>
          <span class="hljs-comment">// Press Ctrl+C to exit the program</span>
        }
        
        <span class="hljs-title function_">consumeMessage</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);
        </code>
    </div>

    <p>
      In this example:

      - The producer sends a message ("Hello RabbitMQ!") to a queue named "hello".
      - The consumer waits for messages on the same queue and prints them to the console.
      - Both the producer and consumer connect to RabbitMQ using amqp.connect() and create a channel using
      connection.createChannel().
      - They then declare a queue with channel.assertQueue() and send/consume messages using channel.sendToQueue() and
      channel.consume(), respectively.
      - Finally, they close the connection and channel after their work is done.<br><br>
      To run this example, you should start the consumer first and then the producer. You should see the consumer
      logging the received message when the producer sends it.
    </p>
  </div>

  <div id="30" class="con">
    <h2>Validate message from RabbitMQ</h2>
    <p>We can use Joi as a library for data validation. It allows you to define schemas and validate data
      against those schemas.</p>

    <div class="code">
      <code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> amqp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'amqplib'</span>);
          <span class="hljs-keyword">const</span> <span class="hljs-title class_">Joi</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'joi'</span>);
          
          <span class="hljs-comment">// Define schema for incoming data using Joi</span>
          <span class="hljs-keyword">const</span> schema = <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">object</span>({
            <span class="hljs-attr">name</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>).required(),
            <span class="hljs-attr">age</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">number</span>().<span class="hljs-title function_">integer</span>().<span class="hljs-title function_">min</span>(<span class="hljs-number">18</span>).required()
          });
          
          <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleMessage</span>(<span class="hljs-params">message</span>) {
            <span class="hljs-keyword">try</span> {
              <span class="hljs-comment">// Parse incoming JSON message</span>
              <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(message.<span class="hljs-property">content</span>.<span class="hljs-title function_">toString</span>());
          
              <span class="hljs-comment">// Validate data against schema</span>
              <span class="hljs-keyword">const</span> validationResult = schema.<span class="hljs-title function_">validate</span>(data);
          
              <span class="hljs-keyword">if</span> (validationResult.<span class="hljs-property">error</span>) {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Validation failed:'</span>, validationResult.<span class="hljs-property">error</span>.<span class="hljs-property">message</span>);
                <span class="hljs-comment">// Handle validation error (e.g., send rejection message)</span>
                <span class="hljs-keyword">return</span>;
              }
          
              <span class="hljs-comment">// Data is valid, process it further</span>
              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Valid data:'</span>, data);
            } <span class="hljs-keyword">catch</span> (error) {
              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error processing message:'</span>, error);
            }
          }
          
          <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">consumeMessages</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">const</span> connection = <span class="hljs-keyword">await</span> amqp.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'amqp://localhost'</span>);
            <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">createChannel</span>();
          
            <span class="hljs-keyword">const</span> queueName = <span class="hljs-string">'my_queue'</span>;
            <span class="hljs-keyword">await</span> channel.<span class="hljs-title function_">assertQueue</span>(queueName, { <span class="hljs-attr">durable</span>: <span class="hljs-literal">false</span> });
          
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Waiting for messages...'</span>);
          
            channel.<span class="hljs-title function_">consume</span>(queueName, handleMessage, { <span class="hljs-attr">noAck</span>: <span class="hljs-literal">true</span> });
          }
          
          <span class="hljs-title function_">consumeMessages</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);
          </code>
    </div>
  </div>

  <div id="31" class="con">
    <h2>Callback function</h2>
    <p>
      Callback functions are functions passed as arguments to other functions, which are then invoked or executed inside
      the outer function. They are commonly used in JavaScript for asynchronous operations or to achieve more flexible
      and reusable code.
    </p>
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript"><span class="hljs-comment">// Function that takes a callback as an argument</span>
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name, callback</span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello, "</span> + name + <span class="hljs-string">"!"</span>);
            <span class="hljs-comment">// Invoke the callback function</span>
            <span class="hljs-title function_">callback</span>();
        }
        
        <span class="hljs-comment">// Callback function</span>
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayGoodbye</span>(<span class="hljs-params"></span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Goodbye!"</span>);
        }
        
        <span class="hljs-comment">// Call the greet function and pass the callback function as an argument</span>
        <span class="hljs-title function_">greet</span>(<span class="hljs-string">"Alice"</span>, sayGoodbye);
        </code>
    </div>
    <p>Output:<br>
      Hello, Alice!<br>
      Goodbye!
    </p>

  </div>

  <div id="32" class="con">
    <h2>Architectural patterns</h2>
    <p>Architectural patterns are high-level design templates or blueprints that provide solutions to commonly occurring
      architectural problems in software development. These patterns help in structuring and organizing the components
      of a system, making it easier to understand, maintain, and scale. Some of the commonly used architectural patterns
      include:</p>
    <br>
    <p>
      <b>Client-Server Architecture</b>: In this pattern, the system is divided into client and server components, where
      clients
      request services or resources from servers. It facilitates distribution of processing tasks between clients and
      servers, enabling scalability and centralized management of resources.
    </p>
    <br>
    <p>
      <b>Microservices Architecture</b>: This architectural style decomposes the system into a collection of small,
      loosely
      coupled services, each responsible for a specific business function. Microservices communicate over lightweight
      protocols like HTTP or message queues. This pattern enables flexibility, scalability, and independent deployment
      of
      services.
    </p>
    <br>
    <p>
      <b>Event-Driven Architecture (EDA)</b>: In EDA, components of the system communicate by producing and consuming
      events.
      Events represent significant occurrences or state changes within the system. This pattern promotes loose coupling,
      scalability, and responsiveness to changes.
    </p>
    <br>
    <p>
      <b>Model-View-Controller (MVC)</b>: MVC separates the system into three interconnected components: Model (data
      and
      business
      logic), View (user interface), and Controller (handles user input and controls the flow of the application). This
      pattern facilitates modularity, reusability, and maintainability of the system.
    </p>
    <br>
    <p>
      <b>Service-Oriented Architecture (SOA)</b>: SOA decomposes the system into a collection of services that are
      loosely
      coupled, self-contained, and interoperable. These services expose functionalities through standardized interfaces
      (such as APIs) and can be orchestrated to fulfill complex business processes.
    </p>
    <br>
    <p>
      <b>Component-Based Architecture</b>: In this pattern, the system is built from reusable, self-contained software
      components
      that encapsulate specific functionality. Components can be assembled and interconnected to create larger systems,
      promoting reusability and modularity.
    </p>
  </div>

  <div id="33" class="con">
    <h2>AWS Lambda</h2>
    <p>AWS Lambda is a serverless compute service provided by Amazon Web Services (AWS) that allows you to run code
      without provisioning or managing servers. It automatically scales your application by running code in response to
      events and manages resources efficiently.</p>
    <br>
    <p>
      <b>1. Create a Lambda Function</b>:

      Sign in to the AWS Management Console and navigate to the Lambda service.
      Click on "Create function" and choose the authoring option (e.g., Author from scratch).
      Give your function a name, choose the runtime as Node.js, and select an execution role with necessary permissions.
      Click on "Create function" to create the Lambda function.
    </p>

    <p><br>
      <b>2. Write Your Node.js Code</b>:

      In the Lambda function configuration, you'll find an inline code editor where you can write your Node.js code
      directly or upload a ZIP file containing your code.<br>
      Your Node.js code should define a handler function that Lambda will invoke when the function is triggered. The
      handler function receives event data and context information.
    </p>
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript">
      <span class="hljs-built_in">exports</span>.<span class="hljs-property">handler</span> = <span class="hljs-keyword">async</span> (event, context) =&gt; {
      <span class="hljs-comment">// Your Node.js code logic here</span>
    };
    </code>
    </div>
    <br>
    <p><b>3. Configure Triggers</b>:

      AWS Lambda can be triggered by various AWS services or external events. Common triggers include Amazon S3 events,
      Amazon SNS notifications, Amazon API Gateway requests, Amazon DynamoDB streams, and scheduled events via Amazon
      CloudWatch Events.<br>
      Configure the appropriate trigger for your Lambda function based on your application's requirements.</p>

    <br>
    <p><b>4. Testing and Debugging</b>:

      Use the Lambda console's "Test" feature to invoke your function manually with sample event data. You can also test
      your Lambda function locally using the AWS SAM CLI or other testing frameworks.
      Implement logging within your Lambda function to capture relevant information for debugging purposes. Lambda
      function logs can be viewed in Amazon CloudWatch.</p>

    <br>
    <p><b>5. Deployment</b>:

      Once you have tested your Lambda function, you can deploy it to the AWS Lambda service.
      AWS Lambda supports versioning and aliases, allowing you to manage multiple versions of your function and direct
      traffic to specific versions using aliases.</p>

    <br>
    <p><b>6. Monitoring and Management</b>:

      Monitor the performance and health of your Lambda functions using Amazon CloudWatch metrics and alarms.
      Set up AWS X-Ray for distributed tracing to analyze and debug performance issues in your serverless applications.
    </p>

    <br>
    <p><b>7. Cost Optimization</b>:
      AWS Lambda pricing is based on the number of requests and the duration of code execution. Optimize your Lambda
      functions for performance and resource usage to minimize costs.
      Consider using provisioned concurrency to reduce cold start latency for frequently invoked functions.
    </p>

    <br>
    <p>AWS Lambda simplifies the process of deploying and managing applications, allowing developers to focus on writing
      code and delivering value to their customers without worrying about server management.</p>
  </div>

  <div id="34" class="con">
    <h2>Rabbit MQ</h2>
    <p>RabbitMQ is a powerful message broker that enables applications to communicate with each other asynchronously via
      messages. In Node.js, you can use the amqplib library to interact with RabbitMQ. </p>
    <br>
    <b>Producer (sender.js)</b>:
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript">
    <span class="hljs-keyword">const</span> amqp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'amqplib'</span>);

    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">produce</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> connection = <span class="hljs-keyword">await</span> amqp.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'amqp://localhost'</span>);
        <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">createChannel</span>();
        <span class="hljs-keyword">const</span> queueName = <span class="hljs-string">'hello'</span>;
        <span class="hljs-keyword">const</span> message = <span class="hljs-string">'Hello World!'</span>;
        
        <span class="hljs-keyword">await</span> channel.<span class="hljs-title function_">assertQueue</span>(queueName);
        <span class="hljs-keyword">await</span> channel.<span class="hljs-title function_">sendToQueue</span>(queueName, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(message));
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">" [x] Sent %s"</span>, message);
        
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
          connection.<span class="hljs-title function_">close</span>();
          process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">0</span>);
        }, <span class="hljs-number">500</span>);
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);
        }
      }
      <span class="hljs-title function_">produce</span>();
        </code>

    </div>
    <br>
    <b>Consumer (receiver.js)</b>:
    <div class="code">
      <code class="!whitespace-pre hljs language-javascript">
    <span class="hljs-keyword">const</span> amqp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'amqplib'</span>);

    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">consume</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> connection = <span class="hljs-keyword">await</span> amqp.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'amqp://localhost'</span>);
        <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">createChannel</span>();
        <span class="hljs-keyword">const</span> queueName = <span class="hljs-string">'hello'</span>;
        
        <span class="hljs-keyword">await</span> channel.<span class="hljs-title function_">assertQueue</span>(queueName);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">" [*] Waiting for messages in %s. To exit press CTRL+C"</span>, queueName);
        
        channel.<span class="hljs-title function_">consume</span>(queueName, <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">" [x] Received %s"</span>, msg.<span class="hljs-property">content</span>.<span class="hljs-title function_">toString</span>());
         }, { <span class="hljs-attr">noAck</span>: <span class="hljs-literal">true</span> });
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);
      }
    } 
    <span class="hljs-title function_">consume</span>();
        </code>
    </div>



  </div>




</body>

</html>