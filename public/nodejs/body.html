<!DOCTYPE html>

<head>
  <style>
    body {
      font-family: Verdana, Geneva, Tahoma, sans-serif;
      font-size: large;
      background-color: rgb(28, 28, 28);
      color: rgb(226, 234, 241);
    }

    .code {
      font-family: "Consolas";
      font-style: italic;
      color: rgb(132, 219, 2);
      border: 1px;
      border-style: inset;
      padding: 2px;
      margin: 5px;
      width: 98%;
    }

    .con {
      border: 2px;
      border-style: double;
      padding: 5px;
      margin: 5px;
      width: 98%;

    }

    .comment {
      font-size: medium;
      font-style: italic;
      color: rgb(112, 111, 111);
    }

    h2 {
      color: rgb(72, 176, 245);
    }

    h4 {
      color: rgb(71, 144, 177);
      font-style: italic;
    }

    li {
      color: rgb(234, 225, 98);

    }
  </style>

</head>

<body>
  <div id="1" class="con">
    <h2>NodeJS</h2>
    Node.js is an open-source, server-side JavaScript runtime environment built on Chrome's V8 JavaScript engine. It
    allows you to execute JavaScript code on the server, which makes it ideal for building scalable and real-time
    applications.

  </div>

  <div id="2" class="con">
    <h2>Event loop</h2>
    The event loop is a core concept in JavaScript that allows the browser to handle asynchronous operations without
    blocking the main thread.
    The event loop works by constantly checking if there are any tasks in the queue and executing them one by one until
    the queue is empty.

    <h2>Event queue</h2>
    Event queue


  </div>

  <div id="3" class="con">
    <h2>Cluster</h2>
    <ul>
      <li>The cluster module allows you to create multiple processes (that share the same server port).</li>
      <li>With clusters, you can create multi-core CPUs</li>
      <li>Cluster helps you to improve performance</li>
      <li> With cluster, you can handle concurrent requests.</li>
    </ul>
    <br>

    Here's how you can use the cluster module:<br>

    <div class="code">
      const {fork} = require('child_process');<br>
      const child = fork('child.js');<br>
      <br>
      child.send('Hello from parent');<br>
      <br>
      child.on('message', (data)=>{<br>
      console.log(`Data received from Child ${data}`);<br>
      })<br>
      <br>
      <span class="comment">//In Child.js</span>
      <br>
      process.on('message', (mgs)=>{<br>
      console.log(`Message received from parent ${msg}`);<br>
      })<br>
      <br>
      process.send('Hello from child');<br>

    </div>
    <br>
    In this example:<br>
    <ul>
      <li>The master process (cluster.isMaster === true) forks child worker processes (cluster.fork()) equal to the
        number
        of available CPUs.</li>
      <li>Each worker process (cluster.isMaster === false) runs its own server, serving HTTP requests.</li>
      <li>If a worker dies or crashes, the master process receives an 'exit' event and can decide to fork a new worker
        to
        replace it.</li>
    </ul>
    Using the cluster module, you can achieve load balancing across multiple CPU cores, providing better concurrency and
    performance for your Node.js applications.
  </div>

  <div id="4" class="con">
    <h2>Worker Thread</h2>
    Worker threads are the separate thread which runs parallel with the main thread. They are used to perform
    CPU-intensive tasks.

    <div class="code">
      <u>Index.js (main thread)</u><br><br>
      const { Worker } = require('worker_threads');<br>
      <br>
      function nodeWorker(workerData) {<br>
      return new Promise((resolve, reject) => {<br>
      const worker = new Worker('./worker.js', { workerData })<br>
      worker.on('error', (err) => {<br>
      reject({ "statue": "Something went wrong!", err })<br>
      })<br>
      worker.on('message', (data) => {<br>
      resolve(data)<br>
      })<br>
      worker.on('exit', (code) => {<br>
      reject(new Error(`Worker exited with code ${code}`))<br>
      })<br>
      })<br>
      }<br>

      async function createWorker() {<br>
      try {<br>
      let data = {<br>
      msg: "\n Hello again, Please update this text in the text file."<br>
      }<br>
      const workerData = await nodeWorker(data)<br>
      console.log(workerData)<br>
      } catch (error) {<br>
      console.log(error)<br>
      }<br>
      }<br>
      <br>
      createWorker()<br>
      <br>
    </div>

    <div class="code">
      <u>Worker.js (worker thread)</u><br>
      const { parentPort, workerData }=require('worker_threads'); <br>
      const fs=require('fs');<br><br>
      fs.appendFile('./output.txt', workerData.msg, (err, data)=> {<br>
      if (err) return parentPort.postMessage({ status: err })<br>
      return parentPort.postMessage({ staus: 'File saved' })<br>
      }) <span class="comment">//fs.writeFile()</span><br>
    </div>
  </div>

  <div id="5" class="con">
    <h2>Child process</h2>
    <ul>
      <li>The child process is a process that runs in parallel with the main process</li>
      <li>You can use the fork() method to create a child process.</li>
      <li>
        This fork() method creates a new process and establishes a connection with the main process.
      <li>Then there are 2 processes, the parent process, and the child process.</li>
      </li>
    </ul>

    <div class="code">
      const {fork} = require('child_process');<br>
      const child = fork('child.js');<br>
      <br>
      child.send('Hello from parent');<br>
      <br>
      child.on('message', (data)=>{<br>
      console.log(`Data received from Child ${data}`);<br>
      });<br>
      <span class="comment">//In Child.js</span>
      <br>
      process.on('message', (mgs)=>{<br>
      console.log(`Message received from parent ${msg}`);<br>
      });<br>

      process.send('Hello from child');<br>

    </div>

  </div>

  <div id="6" class="con">
    <h2>Stream</h2>
    <ul>
      <li>Stream is used to handle data in chunks rather than loading the entire dataset into memory. </li>
      <li>There are four types of streams in Node.js:<br>
        - Readable<br>
        - Writable<br>
        - Duplex<br>
        - Transform
      </li>
    </ul>


    <div class="code">
      const fs = require('fs');<br>
      <br>
      <span class="comment">// Creating a readable stream</span>
      <br>
      const readableStream = fs.createReadStream('input.txt', 'utf8');<br>
      <br>
      <br>
      <span class="comment">// Creating a writable stream</span>
      <br>
      const writableStream = fs.createWriteStream('output.txt');<br>
      <br>
      <span class="comment">// Pipe the readable stream to the writable stream</span>
      <br>
      readableStream.pipe(writableStream);<br>
      <span class="comment">// You can also listen for events on the streams</span>
      <br>
      readableStream.on('data', (chunk) => {<br>
      console.log(`Received ${chunk.length} bytes of data.`);<br>
      });<br>
      <br>
      readableStream.on('end', () => {<br>
      console.log('Finished reading the file.');<br>
      });<br>
      writableStream.on('finish', () => {<br>
      console.log('Finished writing to the file.');<br>
      });<br>
      <br>

    </div>

    We use the pipe method to pipe the data from the readable stream to the writable stream, effectively handling data
    in chunks.<br>
    <h4>Duplex Stream</h4>
    A duplex stream represents both a readable and a writable stream.<br>
    For example, a network socket can be considered a duplex stream where data can be both read from and written to the
    socket.<br>

    <h4>Transform Stream</h4>
    A transform stream is used to transform data.<br>
    Eg:<br>
    <li>Data compression</li>
    <li> Encryption etc</li>
  </div>

  <div id="7" class="con">
    <h2>Zlib</h2>
    Zlib library is used to compress and decompress streams eg: files, text files


    <div class="code">
      const { createGzip } = require('node:zlib');<br>
      const { pipeline } = require('node:stream');<br>
      const {<br>
      createReadStream,<br>
      createWriteStream,<br>
      } = require('node:fs');<br>


      const gzip = createGzip();<br>
      const source = createReadStream('input.txt');<br>
      const destination = createWriteStream('input.txt.gz');<br>

      pipeline(source, gzip, destination, (err) => {<br>
      if (err) {<br>
      console.error('An error occurred:', err);<br>
      process.exitCode = 1;<br>
      }<br>
      });<br>
      <br>

    </div>

  </div>

  <div id="8" class="con">
    <h2>Buffer class</h2>
    The Buffer class is useful when dealing with binary data while performing read-write operations on the file
    system.<br>
    <div class="code">
      <span class="comment">//It initializes the buffer with given data.</span>
      <br>
      const buffer = Buffer.from('Hello World!', 'utf-8')<br>

      console.log(buffer) <span class="comment">// <Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64 21></Buffer></span><br>
      console.log(buffer.toString('utf-8')) <span class="comment"></span> Hello World!<br>
      console.log(buffer.toString('hex')) <span class="comment">// 48656c6c6f20576f726c6421</span><br>
      console.log(buffer.length) <span class="comment">// 12 - returns the length of the buffer</span><br>
    </div>

    Node.js has been moving towards using more modern approaches for handling asynchronous operations, such as Promises,
    async/await, and the Buffer class is synchronous.
    In modern Node.js applications, you might also encounter the use of TypedArray objects or streams to handle binary
    data more efficiently in certain scenarios.
  </div>

  <div id="9" class="con">
    <h2>Import v/s Require</h2>
    <ul>
      <li>Require is an inbuilt function that is used to include modules that exist in separate files. (It is CommonJS
        Syntax)
        <ol>- const http = require(‘http’)</ol>
      </li>
      <li>The require() is synchronous, ie. it blocks other operations until the module is loaded.</li>
      <li>Import is the modern approach to include external modules.</li>
      <li>It was introduced in ES6 from Node version 12.
        <ol>- import test from ‘./test.js’ </ol>
      </li>
    </ul>
    <div class="code">

    </div>

  </div>

  <div id="10" class="con">
    <h2>How NodeJS prevent blocking code?</h2>
    Node uses a single thread, which means one task can be executed at a time. This is done by using a stack. While
    reading the code from top to bottom, each instruction is pushed into a stack and when its execution is completed, it
    pops out of the stack. Events that take longer time to execute can result in a delay in popping the stack and
    execution of further statements. <br>
    <br>
    So what Node.js allows is the use of Event Loop. Each time when we encounter such a situation, the process causing
    the delay is offloaded from the stack and the execution of that process continues parallel to further execution of
    the main code. Thus, the callback for that function is pushed into a task queue and the code continues to execute
    asynchronously. When the process completes its execution, the callback function returns the desired output from that
    process and resumes normal execution.<br>

    <div class="code">

    </div>

  </div>

  <div id="11" class="con">
    <h2>SECURITY</h2>
    <ul>
      <li>Authentication</li>
      <li>Authorization</li>
      <li>Encryption and Hashing</li>
      <li>Helmet</li>
      <li>CORS</li>
      <li>CSRF Protection</li>
      <li>Rate limiting</li>
    </ul>

    <p><b>Authentication</b>: is when a user tries to login to the appication with the username and password. Once
      authenticated, the server will issue a JSON web token (JWT). So this token can be sent as a bearer token in an
      authorization header on subsequent requests for authentication.</p>
    <p><b>Authorization</b>: Authorization means a user who has logged to the the application can access some protected
      routes or no. Role based authorization is one example. <br>
      You can use <b>Guards</b> for role based authorization.
    <ul>
      <li>A guard is a class annoted with the '@'Injectable() decorator. Guards should implemement the CanActivate
        inerface.</li>
      <li>It stands between the client (user) and the route handler.</li>
      <li>It has a single responsibility. They determine whether a given request will be handled by the route handler or
        not, depending on certain conditions (like permission, roles ACLs etc.)</li>
    </ul>
    </p>

    <p><b>Encryption and Hashing</b>: Encryption is a process where you convert the sensative data into an alternative
      form and only an authorized party can Decrypt it. You can use crypto module to encrypt and decrypt the data.<br>
      For Hashing you can use bcrypt or argon2 modules.</p>

    <span class="comment">Encrypt the text 'abc'</span>
    <div class="code">
      var crypto = require('crypto');<br>
      <br>
      var mykey = crypto.createCipher('aes-128-cbc', 'mypassword');<br>
      var mystr = mykey.update('abc', 'utf8', 'hex')<br>
      mystr += mykey.final('hex');<br>
      <br>
      console.log(mystr); <span class="comment">//34feb914c099df25794bf9ccb85bea72</span><br>
    </div>
    <br>
    <span class="comment">Decrypt back to 'abc'</span>
    <div class="code">
      var crypto = require('crypto');<br>
      <br>
      var mykey = crypto.createDecipher('aes-128-cbc', 'mypassword');<br>
      var mystr = mykey.update('34feb914c099df25794bf9ccb85bea72', 'hex', 'utf8')<br>
      mystr += mykey.final('utf8');<br>

      console.log(mystr); <span class="comment">//abc</span>
    </div>


    <p><b>Helmet</b>: With helmet you can secure HTTP response headers. Each headers can be configured. By default,
      Helmet sets the following headers:</p>
    <ul>
      <li>X-Frame-Options: Legacy header that mitigates clickjacking attacks</li>
      <li>X-Content-Type-Options: Avoids MIME sniffing</li>
      <li>Cross-Origin-Resource-Policy: Blocks others from loading your resources cross-origin</li>
    </ul>

    <p><b>CORS</b>: Cross-origin resource sharing (CORS) is a mechanism that allows resources to be requested from
      another domain.</p>

    <p><b>CSRF Protection</b>: Cross Site Request Forgery (CSRF) is one of the most severe vulnerabilities which can be
      exploited in various ways - from changing user's info without his knowledge to gaining full access to user's
      account.
    </p>















    When we build a NestJS application in the backend, we usually separate our logic into controllers and services.
    Controllers are responsible for handling incoming requests and returning responses for the clients, and services are
    responsible for executing the business logic.

    <h4>Use Code Reviews to Identify Potential Security Threats: </h4>
    <ul>
      <li>Peer reviews</li>
      <li>Test your code and write unit tests for all areas of concern.</li>
    </ul>
    <h4>Use Static Code Analysis Tools - Eg Sonarqube</h4>
    <ul>
      <li> Before your software is deployed, static code analysis tools are an excellent approach to finding software
        vulnerabilities. It can be integrated into the pipeline so that every time there is a new build, and it will
        automatically run through these checks and flag any potential issues.</li>
    </ul>

    <br>
    Follow standard coding guidelines<br>
    <h4>Encryption:</h4>
    <ul>
      <li> Encryption is the only way to maintain the confidentiality of user data on a network where any node can
        potentially become compromised by an attacker who will have full access to all traffic they observe.</li>
    </ul>


    <h4>Password Hashing -</h4>
    <ul>
      <li>Use a password hashing algorithm to compute a unique hash of the user's password that can be stored in your
        database.</li>
      <li>Eg: Password Hashing with a Crypto module</li>
    </ul>
    <h4>SQL Injection</h4>
    <ul>
      <li>SQL injection attack is when a hacker inserts a SQL query through an application interface to extract or
        manipulate data from the back-end database.</li>
      <li>SQL injection attacks can be prevented by using parameterized queries instead of dynamic SQL statements.</li>

    </ul>

    <h4> Cross-Site Scripting (XSS)</h4>
    <ul>
      <li> XSS is a type of attack that occurs when an attacker injects malicious scripts into the application. This
        kind
        of attack aims to get users to click on links that will then send them to malicious sites.</li>
    </ul>


    <h4>Input Validation Attacks</h4>
    <li>Input validation attacks are when an attacker finds a way to manipulate the application into accepting data that
      it shouldn't.</li>
  </div>

  <div id="12" class="con">
    <h2>System Design</h2>
    Plan of Action:<br>
    <li>Requirements and Goals of the System</li>
    - Scope the problem<br>
    - Functional Requirements<br>
    - Non-functional requirements<br>
    <li>High-level Design</li>
    - Discuss the components<br>
    - How components fit together<br>
    <li>Detailed Design</li>
    - Data Modeling<br>
    - Exception Handling<br>
    - Parallel Computing<br>
    - Distributed Environment<br>
  </div>

  <div id="13" class="con">
    <h2>API Security testing</h2>
    You can do:

    <h4>Functional testing</h4>
    Functional testing is the testing of specific functions within the codebase. It makes sure the API works within the
    expected parameters like,
    <uL>
      <li>returns the expected output for a particular request sent to the server</li>
      <li>How the API handles the errors when the results are outside of the expected parameters.</li>
      <li>You can do negative testing with invalid requests and check how your API handles those requests, whether it is
        throwing appropriate errors or not.</li>
    </uL>
    <h4>Performance testing</h4>
    In performance testing, you ensure that the API remains functional and reliable under higher load.

  </div>
  <div id="14" class="con">
    <h2>Kafka</h2>
    Apache Kafka is an open-source, distributed, pub-sub messaging system, written in Scala and Java.
    You can send asynchronous communications in the form of the stream to the Kafka cluster.

    <h4>Terminology</h4>
    <ul>
      <li>Producer - An application that sends messages to Kafka</li>
      <li>Consumer - An application that receives data/messages from Kafka</li>
      <li>Broker - Kafka server</li>
      <li>Cluster - Group of computers</li>
      <li>Topic - A name for a Kafka stream</li>
      <li>Partitions - Part of a topic</li>
      <li>Offset - Unique id for a message within a partition</li>
      <li>Consumer groups - A group of consumers acting as a single logical unit</li>
    </ul>

    <h4>Cluster</h4>
    In distributed systems a cluster is a group of computers working togethe for a common purpose.
    Topic: A topic is a unique name for a data stream.

    <h4>Partition</h4>
    The broker stores data for a topic, this data can be huge, it can be larger than the storing capacity of
    a single computer. So we can break that data into 2 or more parts and distribute it on multiple computers. Kafta is
    a distributed system that runs on a cluster of computers. Kafka does not know how many partitions to create it's up
    to us, we have to make that decision. When we create a topic we take that decision and Kafka broker will create that
    many partitions for your topic. Every partition sits on a single machine, you cannot break it again, so do some
    estimation and simple math to calculate the number of partitions.
    <h4>Offset</h4>
    A sequence number given to the messages as they arrive in a partition. They are unique and do not change.
    Offsets are local to the partition.

    To locate a message you need three things:
    <ul>
      <li>Topic name</li>
      <li>Partition number</li>
      <li>Offset</li>
    </ul>




    Partitioning and Consumer group is a tool for scalability.
    The maximum number of consumers in a group is the total number of partitions you have on the topic. Kafka does not
    allow more then two consumer to read form the same partition simultaneously, this restriction is necessary to avoid
    double reading of the records.





    <div class="code">

    </div>

  </div>

  <div id="15" class="con">
    <h2>Crypto</h2>

  </div>


  <div id="16" class="con">
    <h2>Express JS</h2>
    Express is a routing and middleware web framework. An Express application is essentially a series of middleware
    function calls.
    <ul>
      <li>Npm init -y → creates package.json file</li>
      <li>Npm i express</li>
      <li>npm i --save dev nodemon</li><span class="comment">//In package.json -> Inside scripts - >devStart": "nodemon
        server.js"</span>
      <li>Npm i ejs </li><span class="comment">//view engine to render files</span>
    </ul>
  </div>


  <div id="17" class="con">
    <h2>Middleware</h2>
    Middleware are functions that have access to the request object (req), the response object (res), and the next
    function in the application’s request-response cycle. <br>
    <br>
    The next function is a function in the Express router which, when invoked, executes the middleware succeeding the
    current middleware.<br>
    <br>
    To load the middleware function, call app.use(), specifying the middleware function. <br>

    <ul>
      <li>app.use(myLogger)</li>
    </ul>
    <br>

    If the current middleware function does not end the request-response cycle, it must call next() to pass control to
    the next middleware function. Otherwise, the request will be left hanging. Eg:<br>

    <div class="code">
      const myLogger = function (req, res, next) {<br>
      console.log('LOGGED');<br>
      next();<br>
    </div>
    <br><i>
      Notice the call above to next(). Calling this function invokes the next middleware function in the app. The next()
      function is not a part of the Node.js or Express API, but is the third argument that is passed to the middleware
      function. The next() function could be named anything, but by convention, it is always named “next”. To avoid
      confusion, always use this convention.</i>
    <h4>Using Middleware</h4>
    Middleware functions can perform the following tasks:
    <ul>
      <li>Execute any code.</li>
      <li>Make changes to the request and the response objects.</li>
      <li>End the request-response cycle.</li>
      <li>Call the next middleware function in the stack.</li>
    </ul>
  </div>


  <div id="18" class="con">
    <h2>Types of Middlewares</h2>
    <ul>
      <li>Application-level middleware</li>
      <li>Router-level middleware</li>
      <li>Error-handling middleware</li>
      <li>Built-in middleware</li>
      <li>Third-party middleware</li>
    </ul>

    <h4>Application-level middleware</h4>
    Application-level middleware binds to app Object by using the app.use() and app.METHOD() functions, where METHOD is
    the HTTP method of the request that the middleware function handles (such as GET, PUT, or POST).<br>
    <br>
    <div class="code">
      const express = require('express');<br>
      const app = express();<br>
      <br>
      app.use((req, res, next) => {<br>
      console.log('Time:', Date.now())<br>
      next();<br>
      })<br>


    </div>
    <h4>Router-level middleware</h4>
    Router-level middleware works in the same way as application-level middleware, except it is bound to an instance of
    express.Router().<br>
    <br>

    <div class="code">
      const express = require('express');<br>
      const router = express.Router();<br>
      router.get('/user/:id', (req, res, next) => {<br>
      console.log(req.params.id)<br>
      res.render('special')<br>
      })<br>
      <br>
    </div>
    <h4>Error-handling middleware</h4>
    Error-handling middleware functions in the same way as other middleware functions, except with four arguments
    instead of three, specifically with the signature (err, req, res, next)<br>
    <br>
    <div class="code">
      app.use((err, req, res, next) => {<br>
      console.error(err.stack);<br>
      res.status(500).send('Something broke!')<br>
      })<br>
      <br>
    </div>
    <h4>Built-in middleware</h4>
    Express has the following built-in middleware functions:
    <ul>
      <li>express.static serves static assets such as HTML files, images, and so on.</li>
      <li>express.json parses incoming requests with JSON payloads.</li>
      <li>express.urlencoded parses incoming requests with URL-encoded payloads.</li>
    </ul>

    <h4>Third-party middleware</h4>

    <ul>
      <li>Body-parser</li>
      <li>Cors</li>
      <li>Multer </li>
      <li>Cookie-parser</li>
    </ul>

    <div class="code">
      <span class="comment">// Parse incoming request bodies in a middleware before your handlers, available under the
        req.body property.</span><br>

      const bodyParser = require('body-parser');<br>
      app.use(bodyParser.json())<br>
      <br>
      <span class="comment"> // Enable cross-origin resource sharing (CORS) with various options.</span><br>

      const cors = require('cors');<br>
      app.use(cors());<br>
      <span class="comment">//Multer - Handle multi-part form data.<br>
        //Multer is used for uploading files<br>
        //form action="/profile" method="post" enctype="multipart/form-data"//<br>
        //form//</span><br>

      const multer = require('multer');<br>
      const upload = multer({ dest: 'uploads/' });<br>
      app.post('/profile', upload.single('avatar'), function (req, res, next) { <br>
      <span class="comment">// req.file is the `avatar` file </span><br>
      })<br>

    </div>

  </div>


  <div id="19" class="con">
    <h2>Template engines</h2>
    A template engine enables you to use static template files in your application. At runtime, the template engine
    replaces variables in a template file with actual values and transforms the template into an HTML file sent to the
    client.<br><br>

    <div class="code">
      app.set('view engine', 'ejs');<br>
      app.get('/', (req, res, next)=>{<br>
      res.render('index', {text: "Hello World!!"})<br>
      })<br>
    </div>

    <ul>
      <li>To pass information from the server down into the views, the render function takes the second parameter as an
        object. res.render('index', {text: "Hello World!!"})</li>
      <li>Inside view.ejs file.<span class="comment"> //%= local.text % </span></li>
    </ul>

  </div>


  <div id="20" class="con">
    <h2>Process Manager</h2>

    When you run Express apps for production, it is helpful to use a process manager to:
    <ul>
      <li>Restart the app automatically if it crashes.</li>
      <li>Gain insights into runtime performance and resource consumption.</li>
      <li>Modify settings dynamically to improve performance.</li>
      <li>Control clustering.</li>
    </ul>
    <br>
    A process manager is somewhat like an application server: it's a "container" for applications that facilitates
    deployment, provides high availability, and enables you to manage the application at runtime.<br><br>
    The most popular process managers for Express and other Node.js applications are:<br>
    <ul>
      <li> Forever: A simple command-line interface tool to ensure that a script runs continuously (forever). Forever's
        simple interface makes it ideal for running smaller deployments of Node.js apps and scripts.</li>
      <li>PM2: A production process manager for Node.js applications that has a built-in load balancer. PM2 enables you
        to keep applications alive forever, reloads them without downtime, helps you to manage application logging,
        monitoring, and clustering.</li>
      <li>StrongLoop Process Manager (Strong-PM): A production process manager for Node.js applications with built-in
        load balancing, monitoring, and multi-host deployment. Includes a CLI to build, package, and deploy Node.js
        applications to a local or remote system.</li>
    </ul>

  </div>
  <div id="21" class="con">
    <h2>Security Best Practices</h2>
    Most of the time older versions are not maintained, so it's better to migrate to the latest version.<br>
    <br>
    If you are dealing with sensitive data, it is better to use SSL, This technology encrypts data before it is sent
    from the client to the server, thus preventing some common hacks like packet sniffing. TLS is the next level of SSL.
    <br><br>
    Packet sniffing is the process of intercepting the data stream that flows across the network, you can capture each
    packet and, if needed, decode the packet's raw data. This way you can get access to the raw value.
    <br><br>
    You can use Helmet. Helmet helps protect your application by setting HTTP headers appropriately.
    <br><br>
    <ul>
      <li>Content-Security-Policy header. This helps prevent cross-site scripting attacks.</li>
      <li>X-Frame-Options header. This provides clickjacking protection.</li>
      <li> Strict-Transport-Security header. This helps enforce secure (HTTPS) connections to the server.</li>
    </ul>
    <br>

    <b>Clickjacking</b> - When an attacker uses multiple transparent or opaque layers to trick a user into clicking on a
    button
    or link on another page.
    <br><br>
    Helmet is a collection of smaller middleware functions that set security-related HTTP response headers.
    <br><br>
    Security best practices for Express applications in production include:
    <ul>
      <li>Don't use deprecated or vulnerable versions of Express</li>
      <li>Use TLS (Transport Layer Security)</li>
      <li>Use Helmet</li>
      <li>Use cookies securely</li>
      <li>Prevent brute-force attacks against authorization</li>
      <li>Ensure your dependencies are secure</li>
      <li>Avoid other known vulnerabilities</li>
    </ul>
  </div>

  <div id="22" class="con">
    <h2>Performance best practices</h2>
    For performance best practices there are some things you can do with development and some things you have to do in
    your environment/setups.<br><br>

    <u>Things to do while development</u>:

    <h4>Handle exceptions properly</h4>
    So during development, you see that you are doing proper error handling in your code, and uncaught exceptions might
    crash your application, to avoid crashing see that you do proper exception handling. <br>

    You can use Promises, and try-catch blocks to catch errors.<br>

    <h4>error-first callbacks</h4>

    In Node/Express you can do error handling by using error-first callbacks. It is a convention for returning errors
    from asynchronous functions, where the first parameter to the callback function is the error object, followed by
    result data in succeeding parameters. <br><br>

    To indicate no error, pass null as the first parameter. <br><br>

    The best practice is to use the next() function to propagate errors through the middleware chain.<br>

    <h4>Implement Logs</h4>
    You can use the logging library to log all the activities. Eg: Winston<br>

    <h4>Avoid synchronous functions</h4>The synchronous function takes milliseconds to execute, if there is high traffic
    then these synchronous functions might reduce the performance.<br>

    <u>Things to do in Env - setup</u>:

    <ul>
      <li>Set NODE_ENV to "production"</li>
      <li>Ensure your app automatically restarts</li>
      <li>Run your app in a cluster</li>
      <li>Cache request results - Use Redis </li>
      <li>Use a load balancer</li>
      <li>Use a reverse proxy</li>
    </ul>

    In production, you can set NODE_ENV using Upstart. <br>
    With Upstart, use the env keyword in your job file. For example: # /etc/init/env.conf<br>
    <div class="code">env NODE_ENV=production</div>
    <br>
    Upstart is a system tool available on many Linux distributions for starting tasks and services during system
    startup, stopping them during shutdown, and supervising them. You can configure your Express app or process manager
    as a service and then Upstart will automatically restart it when it crashes.
    <br> <br>
    In development, you set environment variables in your interactive shell, by using export or your .bash_profile file.
    <br> <br>

    <b>Ensure your app automatically restarts</b>
    <ul>
      <li>Using a process manager to restart the app (and Node) when it crashes.</li>
      <li>Use the init system provided by your OS to restart the process manager when the OS crashes. It's also possible
        to use the init system without a process manager.</li>
    </ul>













  </div>



</body>

</html>