<!DOCTYPE html>

<head>
  <link rel="stylesheet" href="./../notes_style.css">
  <style>
    body {
      font-family: 'Courier New', Courier, monospace;
      font-size: 17px;
      background-color: rgb(28, 28, 28);
      color: rgb(226, 234, 241);
    }

    .code {
      font-family: "Consolas";
      color: rgb(236, 255, 209);
      border: 1px;
      border-style: inset;
      width: 98%;
    }

    .con {
      background-color: black;
      border: 2px;
      border-style: double;
      padding: 3px;
      margin: 3px;
      width: 98%;

    }

    .comment {
      font-size: medium;
      font-style: italic;
      color: rgb(112, 111, 111);
    }

    h2 {
      color: rgb(72, 176, 245);
    }

    h4 {
      color: rgb(71, 144, 177);
      font-style: italic;
    }

    li {
      color: rgb(234, 225, 98);
    }

    u {
      color: rgb(0, 221, 203);
    }

    .cmd {
      color: rgb(124, 255, 141);
      font-family: 'Courier New', Courier, monospace;
    }

    b {
      color: rgb(255, 226, 61);
    }

    .keyword {
      color: rgb(93, 190, 255);
    }

    .class {
      color: rgb(255, 61, 77);
    }
  </style>

</head>

<body>
  <div id="1" class="con">
    <h2>Setup</h2>
    <p>Angular is a component-based framework for building scalable web applications.</p>
    <ul>
      <li>To install the Angular CLI > <span class="cmd">npm install -g @angular/cli</span></li>
      <li>Check Angular Version > <span class="cmd">ng version</span></li>
      <li>To create a new workspace > <span class="cmd">ng new my-app</span></li>
      <li>Run the application > <span class="cmd">ng serve</span></li>
      <li>Check TypeScript version > <span class="cmd">tsc -v</span></li>
    </ul>

    <b>Folder Structure:</b>
    <ul>
      <li>- TypeScript > The goal of typescript is to make JavaScript strongly typed, it give you object oriented
        feeling
        when you write code using typescript, and it increases productivity.</li>
      <li>- package.json > It has all the dependencies of Angular. You can also see the versions in which these
        angular dependencies are installed.</li>
      <li>- package-lock.json > It is a auto-generated file which locks down the versions of every insatlled packages,
        prevent unintended updates. '<b>package-lock.json</b>' is crucial for locking dependencies to specific versions,
        ensuring consistent installations across different environments. Without it, variations in installed versions
        may occur. This file guarantees reproducibility by specifying exact versions, preventing discrepancies.
        Including both `package.json` and `package-lock.json` in source control ensures that collaborators install the
        exact dependencies, maintaining uniformity. </li>
    </ul>
    <br>
    <p><b>Angular Flow:</b>
      First UI to run is the index.html, The Index.html call the main.ts, The main.ts calls the AppModule. Bootstrap in
      AppModule load the first component in the application, ie. the App.Component.ts, inside the selector, app-root in
      index.html.
    </p>

  </div>

  <div id="2" class="con">
    <h2>Components</h2>
    <p>Angular is a component-based framework for building scalable web applications. Components are the main building
      blocks for Angular applications. Each component consists of:</p>
    <ul>
      <li>- An HTML template that declares what renders on the page</li>
      <li>- A TypeScript class that defines behavior</li>
      <li>- A CSS selector that defines how the component is used in a template</li>
    </ul>
    <b>Generate component</b>
    <ul>
      <li><span class="cmd">ng generate component [name]</span></li>
    </ul>
    <p><b>Decorator</b><br>
      A decorator is a special kind of declaration that can be attached to classes, methods, accessors, properties, or
      parameters. Decorators are used to provide metadata about the element they decorate.
    </p>
    <p>Angular decorators typically start with the '@' symbol followed by the name of the decorator function. <br>
      For example, in Angular, @Component, @NgModule, @Directive, @Pipe, etc., are all decorators. They are used to
      annotate and configure various elements of an Angular application </p>
    <p><br>
    <ul>
      <li><u>@Component</u>: Decorates a class as an Angular component, providing metadata such as selector, template
        URL, style URLs, etc.</li>
      <li><u>@NgModule</u>: Decorates a class as an Angular module, providing metadata such as declarations, imports,
        providers, etc.</li>
      <li><u>@Directive</u>: Decorates a class as an Angular directive, providing metadata such as selector, inputs,
        outputs, etc.</li>
      <li><u>@Pipe</u>: Decorates a class as an Angular pipe, providing metadata such as name, pure, etc.</li>
    </ul>

    </p>
    <div class="code">
      <code class="!whitespace-pre hljs language-typescript">
      <span class="hljs-meta">@Component</span>({
      <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
      <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">'./app.component.html'</span>,
      <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">'./app.component.css'</span>]
      })
      </code>
    </div>

    <b>Component Lifecycle</b>
    <ul>
      <li>The component's lifecycle starts when Angular initializes the component, Then the component changes as per
        change detection, and the lifecycle ends when Angular destroys the component instance and removes its from the
        DOM.</li>
    </ul>
    <p>Component Lifecycle Hooks</p>
    <ul>
      <li><u>ngOnChanges</u> - When an input or output binding value changes.</li>
      <li><u>ngOnInit</u> - After the first ngOnChanges.</li>
      <li><u>ngDoCheck</u> - Developer's custom change detection.</li>
      <li><u>ngOnDestroy</u> - Just before the directive is destroyed.</li>
    </ul>
    <br>
    <p><u>Sharing data between child and parent directives and components</u></p>
    <ul>
      <li>- '@'Input() and Output() decorators give a child component a way to communicate with its parent component.
      </li>
      <li>- '@'Input() decorator, data flows from parent to child, To use Input() decorator, you must configure both
        parent and child.</li>
      <li>- '@'Output() decorator, the data flow from the child to the parent component.</li>
      <li>- Use EventEmitter class to while using '@'Output() decorator</li>
      <li>- <span class="cmd">'@'Output() newItemEvent = new EventEmitter<string>();</span></li>
      <li>- <span class="cmd">this.newItemEvent.emit(value);</span></li>
    </ul>

    <p>Use '@'Input() and '@'Output() on the same child component as follows:</p>
    <ul>
      <li><span class="cmd">child-component [item]="currentItem" (deleteRequest)="crossOffItem($event)"
          /child-component</span></li>
    </ul>

  </div>

  <div id="3" class="con">
    <h2>Templates</h2>
    <p>In Angular, a template is a blueprint for a fragment of a user interface (UI), written in HTML, and syntax</p>

    <p>Templates syntax</p>
    <ul>
      <li><u>Interpolation</u> - Uses the double curly braces <span class="cmd">{{ and }}</span> as delimiters.</li>
      <li><u>Property binding</u> - In property binding you set values for properties of HTML elements or directives.
      </li>
      <li>Eg, img tag: <span class="cmd">img alt="item" [src]="itemImageUrl"</span></li>
      <li><u>Event binding</u> - <span class="cmd">button (click)="onSave()" Save /button</span></li>
      <li><u>Attributes</u> - Provides additional information about that particular element. </li>
      <li>Attributes in HTML - src, alt, id, href, style, lang, width, height</li>
      <li><u>Class and style binding</u> - <span class="cmd">nav [style.background-color]="expression"/nav</span></li>
      <li><u>Two-way data binding</u> - <span class="cmd">app-sizer [(size)]="fontSizePx" app-sizer</span></li>
    </ul>
    <br>
  </div>

  <div id="4" class="con">
    <h2>Pipes</h2>
    <p>Pipes are used in the template expressions to transforme the values. </p>
    <ul>
      <li><u>DatePipe</u>: Formats a date value according to locale rules.</li>
      <li><u>CurrencyPipe</u>: Transforms a number to a currency string, formatted according to locale rules.</li>
      <li>LowerCasePipe , UpperCasePipe</li>
      <li><u>AsyncPipe</u>: Subscribe and unsubscribe to an asynchronous source such as an observable.</li>
      <li>The hero's birthday is {{ birthday | date }}</li>
      <li><u>Chained pipes</u>: The hero's birthday is {{ birthday | date | uppercase}}</li>
    </ul>
    <div class="code">
      import { Component } from '@angular/core';<br>
      import { DatePipe } from '@angular/common';<br>
      <br>
      '@'Component({<br>
      standalone: true,<br>
      selector: 'app-birthday',<br>
      templateUrl: './birthday.component.html',<br>
      imports: [DatePipe],<br>
      })<br><br>
      export class BirthdayComponent {<br>
      birthday = new Date(1988, 3, 15); // April 15, 1988 -- since month parameter is zero-based<br>
      }<br>
      <br>
    </div>
    <br>

    <h3>Custom Pipe</h3>

    <div class="code">

      <span class="keyword">import</span> { <span class="keyword">Pipe, PipeTransform</span> } <span
        class="keyword">from</span> '@angular/core';
      <br>
      '@'Pipe({<br>
      name: 'custom'<br>
      })<br>
      <span class="keyword">export class</span> <span class="class">CustomPipe</span> <span
        class="keyword">implements</span> <span class="class">PipeTransform</span> {<br>
      transform(value: any): any {<br>
      return value * 2;<br>
      }<br>
      }<br>

      <span class="comment">import and declare your custom pipe in app.module.ts</span>

      <div class="code">
        import { NgModule } from '@angular/core';<br>
        import { BrowserModule } from '@angular/platform-browser';<br>
        <span class="keyword">import</span> {<span class="class">CustomPipe</span>} <span class="keyword">from</span>
        './custom.pipe'; <span class="comment">// Import your custom pipe</span><br>
        <br>
        '@'NgModule({<br>
        declarations: [<br>
        CustomPipe <span class="comment">// Declare your custom pipe here</span><br>
        ],<br>
        imports: [<br>
        BrowserModule<br>
        ],<br>
        bootstrap: [],<br>
        })<br>
        export class AppModule { }<br>
      </div>



      </app>

    </div>
  </div>

  <div id="5" class="con">
    <h2>Directives</h2>
    <p>Directives are classes that add additional behavior to the elements in your Angular applications.</p>
    <ul>
      <li><b>Component Directives</b> - Components are directives with a template. They are the most common type of
        directive
        used in Angular applications. Components encapsulate HTML templates along with their associated logic into
        reusable, self-contained units. They are the building blocks of Angular applications and are used to create UI
        elements.</li>
      <li><b>Attribute directives</b> - Change the appearance or behavior of DOM elements<br>
        - <u>NgClass</u>: Adds and removes a set of CSS classes.<br>
        - <u>NgStyle</u>: Adds and removes a set of HTML styles.<br>
        - <u>NgModel</u>: Adds two-way data binding to an HTML form element.<br>
      </li>
      <li><b>Structural directives</b> - Change the DOM layout by adding and removing DOM elements.<br>
        - <u>NgIf</u>: Adds and removes a set of CSS classes.<br>
        - <u>NgFor</u>: Adds and removes a set of HTML styles.<br>
      </li>
    </ul>

    <p>Here's an example of an attribute directive that changes the background color of an element based on a condition:
    </p>
    <div class="code">
      <code class="!whitespace-pre hljs language-typescript">
      <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Directive</span>, <span class="hljs-title class_">ElementRef</span>, <span class="hljs-title class_">Input</span>, <span class="hljs-title class_">Renderer2</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

      <span class="hljs-meta">@Directive</span>({
        <span class="hljs-attr">selector</span>: <span class="hljs-string">'[appHighlight]'</span>
      })
      <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HighlightDirective</span> {
        <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> el: ElementRef, <span class="hljs-keyword">private</span> renderer: Renderer2</span>) {}
        
        <span class="hljs-meta">@Input</span>(<span class="hljs-string">'appHighlight'</span>) <span class="hljs-attr">highlightColor</span>: <span class="hljs-built_in">string</span>;
        
        <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">highlight</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">highlightColor</span> || <span class="hljs-string">'yellow'</span>);
        }
        
        <span class="hljs-keyword">private</span> <span class="hljs-title function_">highlight</span>(<span class="hljs-params">color: <span class="hljs-built_in">string</span></span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderer</span>.<span class="hljs-title function_">setStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>.<span class="hljs-property">nativeElement</span>, <span class="hljs-string">'backgroundColor'</span>, color);
        }
      }
    </code>
    </div>
    <p>And here's how you would use this directive in your HTML template:</p>
    <div class="code">
      <code class="!whitespace-pre hljs language-html">
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">appHighlight</span> [<span class="hljs-attr">highlightColor</span>]=<span class="hljs-string">"'lightblue'"</span>&gt;</span>Highlighted text<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    </code>
    </div>
    <p>In this example, the "<u>appHighlight</u>" directive changes the background color of the div element to light
      blue.</p>

  </div>

  <div id="6" class="con">
    <h2>Dependency Injection</h2>
    <p>When you develop a smaller part of your system, like a module or a class, you may need to use features from other
      classes. For example, you may need an HTTP service to make backend calls. Dependency Injection, or DI, is a design
      pattern and mechanism for creating and delivering some parts of an application to other parts of an application
      that require them. Angular supports this design pattern and you can use it in your applications to increase
      flexibility and modularity.</p>
    <ul>
      <li>'@'Injectable() - The first step is to add the @Injectable decorator to show that the class can be injected.
      </li>
      <li>constructor(private service: HeroService) {} - The most common way to inject a dependency is to declare it in
        a class constructor.</li>
    </ul>
    <p>Hierarchical injectors</p>
    <ul>
      <li>In Hierarchical injectors, you can determine whether to declare a provider at the application level, in a
        Component, or in a Directive</li>
    </ul>

  </div>

  <div id="7" class="con">
    <h2>Best Practices</h2>
    <ul>
      <li><u>Security</u>: Security against cross-site scripting attacks</li>
      <li><u>Accessibility</u>: For people with visual or motor impairements</li>
      <li><u>Keeping up-to-date</u>: To optamize your application there is one way you can do is to keep your
        application
        up-to-date</li>
      <li><u>Property binding best practices</u>: Avoid side effects?????
      </li>
      <li><u>Lazy-loading</u>: By default, NgModules are eagerly loaded. So for large applications with lots of routes,
        we can
        consider using lazy loading, this will help to keep the application (bundle) size small, which in turn helps
        decrease load times.</li>
      <li><u>Lightweight injection token pattern for libraries</u>: The lightweight injection token design pattern is
        especially important for library developers. It ensures that when an application uses only some of your
        library's capabilities, the unused code can be eliminated from the client's application bundle???????</li>
    </ul>

    <p>
      Cross-site scripting (XSS) enables attackers to inject malicious code into web pages and then they can steal your
      sensative data like login username/password or perform actions that impersonate the user.<br>
      To block XSS attacks, you must prevent malicious code from entering the Document Object Model (DOM).<br>
      Eg: <span class="cmd"> img alt="" onerror="..."> and a> href="javascript:..."/a> </span>.

    </p>

    <h2>Security Best Practices</h2>
    Most of the time older versions are not maintained, so it's better to migrate to the latest version.<br>
    <br>
    If you are dealing with sensitive data, it is better to use SSL, This technology encrypts data before it is sent
    from the client to the server, thus preventing some common hacks like packet sniffing. TLS is the next level of SSL.
    <br><br>
    Packet sniffing is the process of intercepting the data stream that flows across the network, you can capture each
    packet and, if needed, decode the packet's raw data. This way you can get access to the raw value.
    <br><br>
    You can use Helmet. Helmet helps protect your application by setting HTTP headers appropriately.
    <br><br>
    <ul>
      <li>Content-Security-Policy header. This helps prevent cross-site scripting attacks.</li>
      <li>X-Frame-Options header. This provides clickjacking protection.</li>
      <li> Strict-Transport-Security header. This helps enforce secure (HTTPS) connections to the server.</li>
    </ul>
    <br>

    <b>Clickjacking</b> - When an attacker uses multiple transparent or opaque layers to trick a user into clicking on a
    button
    or link on another page.
    <br><br>
    Helmet is a collection of smaller middleware functions that set security-related HTTP response headers.
    <br><br>
    Security best practices for Express applications in production include:
    <ul>
      <li>Don't use deprecated or vulnerable versions of Express</li>
      <li>Use TLS (Transport Layer Security)</li>
      <li>Use Helmet</li>
      <li>Use cookies securely</li>
      <li>Prevent brute-force attacks against authorization</li>
      <li>Ensure your dependencies are secure</li>
      <li>Avoid other known vulnerabilities</li>
    </ul>


  </div>

  <div id="8" class="con">
    <h2>Interceptor</h2>
    <p>The http Interceptor basically intercepts the outgoing HTTP requests, transforms them and then sends it to the
      server. The Interceptor modifies the request to contain the token that is stored in the browserâ€™s local storage.
    </p>
  </div>


  <div id="9" class="con">
    <h2>Route Guard</h2>
    <p>Route guards are used to control access to routes in an application. They provide a way to prevent unauthorized
      access to certain routes based on specific conditions, such as authentication status, user roles, or other
      criteria.
      Angular provides several types of route guards out of the box:</p><br>

    <p><b>CanActivate</b>: The CanActivate interface is used to determine if a route can be activated. It's commonly
      used to protect routes
      based on authentication status. If the CanActivate guard returns true, the navigation is allowed; if it returns
      false or a UrlTree, the navigation is canceled.</p><br>

    <p><b>CanActivateChild</b>: Similar to CanActivate, but specifically for protecting child routes of a route. It's
      used to guard against
      unauthorized access to child routes while allowing access to the parent route.</p><br>

    <p><b>CanDeactivate</b>: The CanDeactivate interface is used to determine if a route can be deactivated. It's
      commonly used to prompt the
      user for confirmation before leaving a page with unsaved changes.</p><br>

    <p><b>Resolve</b>: The Resolve interface is used to pre-fetch data before activating a route. It ensures that the
      route data is
      available before the route is rendered, which can be useful for resolving dependencies asynchronously.</p><br>

    <p><b>CanLoad</b>: The CanLoad interface is used to prevent the asynchronous loading of feature modules. It's
      commonly used for
      lazy-loaded modules to guard against unauthorized access to the module's contents.</p>
    <p>To implement route guards, you need to create classes that implement these interfaces and provide logic to
      determine
      whether navigation should be allowed or not. Then, you can attach these guards to routes in your routing
      configuration.
      <br><br>
      Here's an example of how to use route guards:
    </p>


    <div class="code">
      <code class="!whitespace-pre hljs language-typescript">
    <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
    <span class="hljs-keyword">import</span> { <span class="hljs-title class_">CanActivate</span>, <span class="hljs-title class_">Router</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;
    <span class="hljs-keyword">import</span> { <span class="hljs-title class_">AuthService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./auth.service'</span>;
        
    <span class="hljs-meta">@Injectable</span>({
      <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span>
    })
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthGuard</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CanActivate</span> {
        
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> authService: AuthService, <span class="hljs-keyword">private</span> router: Router</span>) {}
        
      <span class="hljs-title function_">canActivate</span>(): <span class="hljs-built_in">boolean</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">authService</span>.<span class="hljs-title function_">isLoggedIn</span>()) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-title function_">navigate</span>([<span class="hljs-string">'/login'</span>]);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }
    }
        </code>
    </div><br>
    <p>In this example, AuthGuard implements the CanActivate interface. It checks if the user is logged in using an
      AuthService. If the user is logged in, canActivate() returns true, allowing navigation. Otherwise, it redirects
      the user to the login page and returns false.<br><br>
      You can then use this guard in your routing configuration:</p>

    <div class="code">
      <code class="!whitespace-pre hljs language-typescript">
  <span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">Routes</span> = [
      { <span class="hljs-attr">path</span>: <span class="hljs-string">'profile'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">ProfileComponent</span>, <span class="hljs-attr">canActivate</span>: [<span class="hljs-title class_">AuthGuard</span>] }
  ];
      </code>
    </div><br>
    <p>This ensures that the AuthGuard is executed before allowing access to the /profile route.</p>
  </div>

  <div id="10" class="con">
    <h2>Observables & RxJS</h2>
    Observables are used to pass values/data across your application. It is a technique for event handling, asynchronous
    programming, and handling multiple values which are emitted over time.
    <br>Angular uses RxJS library fir Observables.

    <b>NOTIFICATION TYPE</b><br>
    <u>next</u>: Required. A handler for each delivered value. Called zero or more times after execution starts.<br>
    <u>error</u>: Optional. A handler for an error notification. An error halts execution of the observable
    instance.<br>
    <u>complete</u>: Optional. A handler for the execution-complete notification. Delayed values can continue to be
    delivered to the next handler after execution is complete.<br>
    For Error handling you use error callbacks on the observer.<br><br>
    <span class="cmd">
      myObservable.subscribe({<br>
      next(num) { console.log('Next num: ' + num)},<br>
      error(err) { console.log('Received an error: ' + err)}<br>
      });<br>
    </span>
    <br>

    <h2>Observables Pattern</h2>
    <p>In Observable pattern, we have Event Emitter, which we call it as observable, and then we also have an
      Observer, which listen to that Observables. So, When ever an Observable emits an event, the observer then handles
      that event using event handlers.</p>

    <br>
    <p><b>Observables(Event Emitter) ------> Observer(Event Listener) -----> Handler (Event Handler)</b></p>

  </div>

  <div id="11" class="con">
    <h2>Lifecycle hooks</h2>
    <p>An Angular Component goes through different phases right from its creation until it is destroyed.</p>
    <uL>
      <li><u>constructor</u> : This is invoked when Angular creates a component or directive by calling new on the
        class.</li>
      <li><u>ngOnChanges</u>: Invoked every time there is a change in one of the input properties of the component.</li>
      <li><u>ngOnInit</u> : Invoked when a given component has been initialized.
        This hook is only called once after the first ngOnChanges
      </li>
      <li><u>ngDoCheck</u>: Invoked when the change detector of the given component is invoked. It allows us to
        implement our
        own change detection algorithm for the given component.
        Use ngDoCheck when you want to capture changes that Angular otherwise doesn't. For example, if a binding
        reference remains unchanged after a click event, ngOnChanges won't run but ngDoCheck will.
      </li>
      <li><u>ngOnDestroy</u>:This method will be invoked just before Angular destroys the component. Use this hook to
        unsubscribe
        observables and detach event handlers to avoid memory leaks.</li>
      <li><u>ngAfterViewChecked</u>: ngAfterViewChecked is useful when you want to call a lifecycle hook after all child
        components have been initialized and checked.</li>
      <li><u>ngAfterViewInit</u>: If you need to access the child component after it's initialized, you can use the
        ngAfterViewInit lifecycle hook. This ensures that the child component is available for interaction. (Refer,
        @ViewChild).</li>
    </ul>
  </div>

  <div id="12" class="con">
    <h2>Async Pipe</h2>
    <p>In Angular, the AsyncPipe is a built-in pipe that allows you to easily work with asynchronous data streams
      directly in your templates. It subscribes to an observable or a promise and automatically handles the subscription
      and unsubscription, as well as the rendering of the emitted values. This is particularly useful for handling data
      that arrives asynchronously, such as data fetched from an HTTP request.<br><br>
      Here's how you can use the AsyncPipe in your Angular templates:
    </p>
    <p><b>Observables</b>: If you have an observable in your component class, you can use the AsyncPipe in the template
      to subscribe to it and render the emitted values.</p>
    <div class="code">
      <code class="!whitespace-pre hljs language-typescript">
      <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
      <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span>, <span class="hljs-keyword">of</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
        
      <span class="hljs-meta">@Component</span>({
        <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-example'</span>,
        <span class="hljs-attr">template</span>: <span class="hljs-string">`
            &lt;div&gt;{{ data$ | async }}&lt;/div&gt;
          `</span>
      })
      <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleComponent</span> {
        <span class="hljs-attr">data$</span>: <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-built_in">any</span>&gt;;
        
        <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">data$</span> = <span class="hljs-title function_">of</span>(<span class="hljs-string">'Hello World'</span>).<span class="hljs-title function_">pipe</span>(
              <span class="hljs-comment">// Simulating async operation</span>
              <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>)
          );
        }
      }
        </code>
    </div>
    <p><b>Promises</b>: Similarly, you can use the AsyncPipe with promises.</p>
    <div class="code">
      <code class="!whitespace-pre hljs language-typescript">
      <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

      <span class="hljs-meta">@Component</span>({
        <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-example'</span>,
        <span class="hljs-attr">template</span>: <span class="hljs-string">`
                &lt;div&gt;{{ dataPromise | async }}&lt;/div&gt;
              `</span>
      })
      <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleComponent</span> {
          <span class="hljs-attr">dataPromise</span>: <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;;
            
          <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataPromise</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
                  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'Hello World'</span>), <span class="hljs-number">1000</span>); <span class="hljs-comment">// Simulating async operation</span>
              });
            }
          }
            </code>
    </div>
  </div>
  <div id="13" class="con">
    <h2>ViewChild Decorator</h2>
    <uL>
      <li>In Javascript we use document.getElementById('con'), to get a reference of our HTML element, and then with DOM
        methods, we manipulate it.</li>
      <li>In Angular, if you want to get a reference of the element of your template file into the component class, in
        that case, you can use ViewChild or ViewChildern.</li>
      <li>If you need to access references of multiple components then use ViewChildren.</li>
    </uL>

    <span class="cmd">
      // In template <br>
      pane id="1" '*'ngIf="shouldShow">/pane><br>
      pane id="2" '*'ngIf="'!'shouldShow">/pane><br>

      <br>
      // In component <br>
      '@'ViewChild(Pane) <br>
      set pane(v: Pane) { <br>
      setTimeout(() => { <br>
      this.selectedPane = v.id; <br>
      }, 0); <br>
      } <br>
    </span>


  </div>
  <div id="14" class="con">
    <h2>Template reference variables / Symbol</h2>
    <p>A template reference variable is a varaible which stores a reference to a DOM element, Component or Directive on
      which it is used.</p>
    <div class="code">
      <code class="!whitespace-pre hljs language-typescript">
    <span class="hljs-comment">// In dashboard.component.ts</span>
    <span class="hljs-attr">searchText</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>;
        
    <span class="hljs-title function_">searchTextfn</span>(<span class="hljs-params">ele: HTMLInputElement</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ele.<span class="hljs-property">value</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">searchText</span> = ele.<span class="hljs-property">value</span>;
    }
        
    <span class="hljs-comment">// In dashboard.component.html</span>
    &lt;input <span class="hljs-keyword">class</span>=<span class="hljs-string">"btn btn-search"</span> #searchInputText /&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"searchTextfn(searchInputText)"</span>&gt;</span>Search<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
        </code>
    </div>

  </div>

  <div id="15" class="con">
    <h2>Typescript</h2>
    TypeScript is a typed language, it is a superset of JavaScript. TypeScript simplifies JavaScript code, making it
    easier to read and debug. <br>
    Current version: 5.3.3
    <br>
  </div>

  <div id="16" class="con">
    <h2>Child Routes</h2>
    <p>Child routes are routes that are nested within another route. This allows you to create hierarchical navigation
      structures in your application. Child routes are often used to organize and modularize your application's routing
      configuration, making it easier to manage and maintain.</p><br>
    <p>Here's how you can define child routes in Angular:</p><br>
    <p>1. <b>Define Parent Route</b>: First, define a parent route in your routing configuration. This is the route that
      will have child routes nested within it.</p>
    <div class="code">
      <code class="!whitespace-pre hljs language-typescript">
    <span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">Routes</span> = [
      {
        <span class="hljs-attr">path</span>: <span class="hljs-string">'parent'</span>,
        <span class="hljs-attr">component</span>: <span class="hljs-title class_">ParentComponent</span>,
        <span class="hljs-attr">children</span>: [
          { <span class="hljs-attr">path</span>: <span class="hljs-string">'child1'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Child1Component</span> },
          { <span class="hljs-attr">path</span>: <span class="hljs-string">'child2'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Child2Component</span> }
        ]
      }
    ];
        </code>
    </div><br>
    <p>2. <b>Parent Component Template</b>: In the parent component's template, you need to include a "router-outlet>
      /router-outlet> directive. This acts as a placeholder where Angular will render the child components associated
      with their respective routes.</p>
    <div class="code">
      <code class="!whitespace-pre hljs language-html">
    <span class="hljs-comment">&lt;!-- parent.component.html --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Parent Component<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span>
        </code>
    </div><br>
    <p>3. <b>Navigate to Child Routes</b>: You can navigate to child routes using relative paths. For example, to
      navigate to child1 from parent, you would use a link like this: </p>
    <div class="code">
      <code class="!whitespace-pre hljs language-html">
      <span class="hljs-comment">//html</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"child1"</span>&gt;</span>Child 1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
        </code>
    </div><br>
    <p>Alternatively, you can use absolute paths by starting the path with a forward slash:</p>
    <div class="code">
      <code class="!whitespace-pre hljs language-html">
    <span class="hljs-comment">//html</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/parent/child1"</span>&gt;</span>Child 1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
      </code>
    </div><br>
    <p>4. <b>Accessing Child Route Parameters</b>: Child routes can also have their own parameters, and you can access
      these parameters using the ActivatedRoute service within the child component.</p>
    <div class="code">
      <code class="!whitespace-pre hljs language-typescript">
    <span class="hljs-keyword">import</span> { <span class="hljs-title class_">ActivatedRoute</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> route: ActivatedRoute</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">route</span>.<span class="hljs-property">params</span>.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">params</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params[<span class="hljs-string">'id'</span>]); <span class="hljs-comment">// Accessing parameter from child route</span>
      });
    }
        </code>
    </div><br>
    <div id="19">
      <p>5. <b>Lazy Loading with Child Routes</b>: You can also lazy load modules with child routes using the
        loadChildren
        property in the route configuration. This can improve the performance of your application by loading modules on
        demand.</p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
    <span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">Routes</span> = [
      {
        <span class="hljs-attr">path</span>: <span class="hljs-string">'parent'</span>,
        <span class="hljs-attr">loadChildren</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./parent.module'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">ParentModule</span>)
      }
    ];
      </code>
      </div><br>
      <p>Child routes provide a powerful way to organize and structure your application's navigation, especially for
        larger applications with complex routing requirements. They help keep your routing configuration clean and
        maintainable by breaking it down into smaller, manageable pieces.</p>
    </div>

  </div>

  <div id="17" class="con">
    <h2>This keyword</h2>
    <p>The <u>"this"</u> keyword always refers to an Object. The value of this always changes as per the scenarion in
      which it is called. </p>
    <p>Some different ways to use "this" keyword</p>
    <ul>
      <li>By itself -- Will refer window Object</li>
      <li>Inside Object method -- Will refer the owner object</li>
      <li>Inside function -- Will refer window object</li>
    </ul>
    <span class="cmd">If you use 'use strict' then you will get 'undefined', if there is no reference to 'this' keyword.
    </span>
    <br>
  </div>


  <div id="18" class="con">
    <h2>Call, Apply and Bind</h2>
    <h4>Call</h4>
    <p>Call, Apply and Bind are built-in pre-defined methods in JavaScript.</p>
    <p>Call is a function that helps you to chnage the context of the invoking function. In other words, it helps you
      replace the value of "this" inside a function with whatever value you want.</p>

    <p> call() method allows an object to use the method of another object.</p>
    <div class="code">
      const person1 = {<br>
      FName: "Raj",<br>
      LName: "Manchekar",<br>
      fullName: function (homeTown, country){<br>
      return this.FName +" "+ this.LName +" "+ this.homeTown +" "+ this.country;<br>
      }<br>
      }<br>
      <br>
      const person2 = {<br>
      FName: "Rhea",<br>
      LName: "Manchekar",<br>
      }<br>
      <br>

      console.log(person1.fullName.call(person2, "Pune", "India")) <span class="comment">//
        First argument is the Object which is borrowing, and second argument is a list of arguments to be passed to the
        method.</span>
      <br>
      <h4>Apply</h4>
      <u>Apply method is same as call method, only difference between the call method and apply method is that you pass
        the arguments as an array in apply.</u>
      <br><br>
      console.log(person1.fullName.apply(person2, ["Pune", "India"])) <span class="comment">Pass arguments in an
        Array</span>
      <br>
      <h4>Bind</h4>
      <p>Bind method creates a copy of a method that can be invoked later. Where as call method invokes instently.</p>

      const result = person1.fullName.bind(person2, "Pune", "India")

      console.log(result()) <span class="comment">// Output will be same as call method.</span>
    </div>
  </div>


  <!-- <div id="19" class="con">
    <h2>...</h2>
    <div class="code">

    </div>
  </div> -->


  <div id="20" class="con">
    <h2>Closure</h2>
    <p>A closure gives you access to an outer function's scope from and inner function.</p>
    <p>A closure is the combination of a function bundled together with reference to it surrounding state.</p>

    <h4>Lexical Environment. Scope in JavaScript</h4>

    <b>Lexical scope</b> is the ability for a function scope to access variable from the parent scope.

    <p>We call the child function to be Lexical bound by that of the parent function.</p>

    <div class="code">
      <code class="!whitespace-pre hljs language-javascript">
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> outerVariable = <span class="hljs-string">'I am from the outer function'</span>;
      
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVariable); <span class="hljs-comment">// Accessing outerVariable from the outer scope</span>
    }
      
    <span class="hljs-keyword">return</span> innerFunction; <span class="hljs-comment">// returning innerFunction</span>
    }
      
    <span class="hljs-keyword">const</span> myInnerFunction = <span class="hljs-title function_">outerFunction</span>(); <span class="hljs-comment">// Execute outerFunction and store the returned innerFunction</span>
      
    <span class="hljs-title function_">myInnerFunction</span>(); <span class="hljs-comment">// Execute innerFunction which still has access to outerVariable</span>
      </code>
    </div>





  </div>
  <div id="21" class="con">
    <h2>Promise</h2>
    <p>
      Promise in JavaScript is object which represents the eventual completion (or failure) of an asynchronous
      operations.
      A Promise take two parameters: 'resolve' and 'reject'.
    </p>

    Eg.
    <div class="code">
      const promise1 = new Promise((resolve, reject) => {<br>
      setTimeout(() => {<br>
      resolve('foo');<br>
      }, 300);<br>
      });<br>
      <br>
      promise1.then((value) => {<br>
      console.log(value);<br>
      <span class="comment">// Expected output: "foo"</span><br>
      });<br>
      <br>
      console.log(promise1);<br>
      <br>
    </div>

    <h2>Promise.all()</h2>
    <p>Promise.all() is useful for aggregating the results of multiple promises. It will reject immediately upon any of
      the input promise is rejected</p>

    <h2>Promise.allSettled()</h2>
    <p>Promise.allSettled() is typically used when you have multiple asynchronous tasks that are not dependent on one
      another to complete successfully, or you'd always like to know the result of each promise.</p>

    <h2>Promise.any()</h2>
    <p>Promise.any() is useful for returning the first promise that fulfills. It does not wait for the other promises to
      complete once it finds one.</p>

    <h2>Promise.race()</h2>
    <p>Promise.race() is useful when you want the first async task to complete, but do not care about its eventual
      state.</p>

    <h2>Async-Await</h2>
    <p>Async-Await is a new JavaScript feature that allows you to write asynchronous code in a synchronous-like
      manner. It's provides cleaner and readable syntax for handling asynchronous operations.</p>

    <div class="code">
      <span class="keyword">async</span> <span class="fn">function</span> fetchData() {<br>
      try {<br>
      const data = <span class="keyword">await</span> fetchDataFromAPI(); <span class="comment">// fetchDataFromAPI()
        returns a promise</span><br>
      console.log(data);<br>
      } catch (error) {<br>
      console.error(error); <span class="comment">// Handle error</span><br>
      }<br>
      }<br>

      <br>
      <span class="fn">fetchData</span>()<br>
      . <span class="fn">then</span>((_data) => console.log('Data fetched successfully', _data))<br>
      . <span class="fn">catch</span>((error) => console.error('Failed to fetch data:', error));<br>
    </div>

    <div id="22" class="con">
      <h2>Optimize your web App</h2>
      <p>
        Debouncing and Throttling concepts are used for optimizing your web app. It happens by limiting the rate of
        execution of API calls.</p>
      Eg: The user types in the search bar to find a product and on every keystroke, we fire an event to fetch the
      data.<br>
      Debouncing is more used in e-commerce sites<br>
      <b>Debouncing</b>: If the difference between the two keystrokes is 300ms<br>
      <b>Throttling</b>: If the difference between the two function calls is 300ms. Calling an API after a certain
      interval of time.
    </div>

    <div id="23" class="con">
      <h2>View Encapsulation</h2>
      <p>THe view encapsulation is a concept where the component css style are encapsulated in components view and it
        does not affect the rest of the application. <br>
        In Angular there are 3 types of encapsulation.
      </p><br>

      <p><b>Emulated (default)</b>: In Emulated type of encapsulation, Angular adds some unique HTML attributes to the
        component CSS style and also to the HTML element. So for each component there will be a unique attribute added
        to each HTML element.
      </p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
  <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span>, <span class="hljs-title class_">ViewEncapsulation</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

  <span class="hljs-meta">@Component</span>({
      <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-example'</span>,
      <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">'./example.component.html'</span>,
      <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">'./example.component.css'</span>],
      <span class="hljs-attr">encapsulation</span>: <span class="hljs-title class_">ViewEncapsulation</span>.<span class="hljs-property">Emulated</span>
          })
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleComponent</span> {
      <span class="hljs-comment">// Component logic here</span>
  }
          </code>
      </div><br>
      <p><b>None</b>: In None, Eg. Button, whatever css syle we have specified to the button element, that CSS style
        will be applied to all the button elements of the child component as well.
      </p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
    <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span>, <span class="hljs-title class_">ViewEncapsulation</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

    <span class="hljs-meta">@Component</span>({
        <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-example'</span>,
        <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">'./example.component.html'</span>,
        <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">'./example.component.css'</span>],
        <span class="hljs-attr">encapsulation</span>: <span class="hljs-title class_">ViewEncapsulation</span>.<span class="hljs-property">None</span>
    })
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleComponent</span> {
        <span class="hljs-comment">// Component logic here</span>
    }
          </code>
      </div><br>
      <p><b>Shadow DOM</b>: Using ShadowDom view encapsulation we can achive true encapsulation, because the component
        creates it own DOM. So the
        browser keeps the shadowDOM seperate from the main DOM, and the rendering of the shadowDOM and the main DOM
        happens seperatly. Thats why the state and style of the component remains private and it does not get effected
        by the main DOM.
      </p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
      <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span>, <span class="hljs-title class_">ViewEncapsulation</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

      <span class="hljs-meta">@Component</span>({
          <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-example'</span>,
          <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">'./example.component.html'</span>,
          <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">'./example.component.css'</span>],
          <span class="hljs-attr">encapsulation</span>: <span class="hljs-title class_">ViewEncapsulation</span>.<span class="hljs-property">ShadowDom</span>
      })
      <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleComponent</span> {
          <span class="hljs-comment">// Component logic here</span>
      }
            </code>
      </div>
    </div>

    <div id="24" class="con">
      <h2>View Child</h2>
      <p>
        In Angular, @ViewChild is a decorator used to access child components, directives, or elements within a parent
        component. It allows the parent component to query and interact with its child components programmatically.<br>
        @ViewChild is particularly useful when you need to access properties or methods of child components from the
        parent component.</p>

      <p>Here's how @ViewChild works:</p>
      <p>1. <b>Import ViewChild</b> :First, import ViewChild from @angular/core in your parent component file.</p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
        <span class="hljs-keyword">import</span> { <span class="hljs-title class_">ViewChild</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
      </code>
      </div>

      <p>2. <b>Decorate the Property</b>: Next, decorate a property in the parent component with @ViewChild. </p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
        <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span>, <span class="hljs-title class_">ViewChild</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
        <span class="hljs-keyword">import</span> { <span class="hljs-title class_">ChildComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./child.component'</span>;
          
        <span class="hljs-meta">@Component</span>({
          <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-parent'</span>,
          <span class="hljs-attr">template</span>: <span class="hljs-string">`
            &lt;app-child&gt;&lt;/app-child&gt;
          `</span>
        })
        <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentComponent</span> {
          <span class="hljs-meta">@ViewChild</span>(<span class="hljs-title class_">ChildComponent</span>) <span class="hljs-attr">childComponent</span>: <span class="hljs-title class_">ChildComponent</span>;
        }
        </code>
      </div>
      <p>3. <b>Access Child Properties and Methods</b>: Now, you can access properties and methods of the child
        component through the childComponent property in the parent component.</p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
        <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

        <span class="hljs-meta">@Component</span>({
          <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-child'</span>,
          <span class="hljs-attr">template</span>: <span class="hljs-string">`
            &lt;p&gt;Child Component&lt;/p&gt;
          `</span>
        })
        <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildComponent</span> {
          <span class="hljs-attr">childProperty</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">'Hello from child'</span>;
          
          <span class="hljs-title function_">childMethod</span>(<span class="hljs-params"></span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Method called from child'</span>);
          }
        }
        </code>
      </div>
      <p>In the parent component:</p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
        <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentComponent</span> {
        <span class="hljs-meta">@ViewChild</span>(<span class="hljs-title class_">ChildComponent</span>) <span class="hljs-attr">childComponent</span>: <span class="hljs-title class_">ChildComponent</span>;
        
        <span class="hljs-title function_">ngAfterViewInit</span>(<span class="hljs-params"></span>) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">childComponent</span>.<span class="hljs-property">childProperty</span>); <span class="hljs-comment">// Output: Hello from child</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">childComponent</span>.<span class="hljs-title function_">childMethod</span>(); <span class="hljs-comment">// Output: Method called from child</span>
        }
      }
      </code>
      </div>
      <p>4. <b>Lifecycle Hook</b>: If you need to access the child component after it's initialized, you can use the
        "<u>ngAfterViewInit</u>" lifecycle hook. This ensures that the child component is available for interaction.</p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
        <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentComponent</span> {
        <span class="hljs-meta">@ViewChild</span>(<span class="hljs-title class_">ChildComponent</span>) <span class="hljs-attr">childComponent</span>: <span class="hljs-title class_">ChildComponent</span>;
          
        <span class="hljs-title function_">ngAfterViewInit</span>(<span class="hljs-params"></span>) {
          <span class="hljs-comment">// Access child component here</span>
        }
      }
      </code>
      </div>
      <br>
      <p>"@ViewChild" allows you to establish communication between parent and child components in Angular, enabling you
        to build more dynamic and interactive applications.</p>
    </div>

    <div id="25" class="con">
      <h2>Modules</h2>
      <p> Angular modules (NgModule) are containers for a group of related components, directives, pipes, and services.
        They help organize an application into cohesive blocks of functionality. Modules help to keep the codebase
        organized, maintainable, and scalable by promoting modularity and encapsulation.</p>
      <br>
      <p>Angular applications typically have at least one root module, called the AppModule, which serves as the entry
        point for the application. Additionally, Angular applications can have multiple feature modules, each focusing
        on a specific feature or aspect of the application.</p>
      <br>
      <p>Key concepts related to Angular modules:</p>
      <ul>
        <li><b>NgModule Decorator</b>: Modules are defined using the @NgModule decorator. This decorator provides
          metadata about the module, such as its declarations, imports, exports, and providers.</li>
        <li><b>Declarations</b>: Components, directives, and pipes that belong to the module are listed here in
          Declarations.</li>
        <li><b>Imports</b>: Imports specify other modules whose exported members should be available within the current
          module. This allows you to reuse functionality from other modules.</li>
        <li><b>Exports</b>: Exports specify which declarations of the module should be accessible to other modules that
          import it.</li>
        <li><b>Providers</b>: Providers are used to register services within the module. Services provided at the module
          level are typically singletons, meaning there is only one instance of the service throughout the application.
        </li>
      </ul>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
        <span class="hljs-keyword">import</span> { <span class="hljs-title class_">NgModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
        <span class="hljs-keyword">import</span> { <span class="hljs-title class_">BrowserModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;
        <span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.component'</span>;
          
        <span class="hljs-meta">@NgModule</span>({
          <span class="hljs-attr">declarations</span>: [
            <span class="hljs-title class_">AppComponent</span>
          ],
          <span class="hljs-attr">imports</span>: [
            <span class="hljs-title class_">BrowserModule</span>
          ],
          <span class="hljs-attr">providers</span>: [],
          <span class="hljs-attr">bootstrap</span>: [<span class="hljs-title class_">AppComponent</span>]
        })
        <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> { }
        </code>
      </div>
      <p>In this example, AppModule is the root module of the application. It declares the AppComponent and imports the
        BrowserModule, which is required for running the application in a web browser. The bootstrap property specifies
        the root component of the application.</p>
    </div>

    <div id="26" class="con">
      <h2>Data Binding</h2>
      <p> Data binding in Angular allows you to synchronize the data between the component and the view. There are four
        types of data binding in Angular: interpolation, property binding, event binding, and two-way binding.</p>

      <ul>
        <li><b>Interpolation</b>: Interpolation is denoted by double curly braces ({{ }}). It allows you to render
          component data in the HTML template.
          <div class="code">
            <code class="!whitespace-pre hljs language-html">
            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{{ title }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
            </code>
          </div>
        </li>
        <li><b>Property Binding</b>: It allows you to set the value of an HTML element property by using square brackets
          [].

          <div class="code">
            <code class="!whitespace-pre hljs language-html">
            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"imageUrl"</span>&gt;</span>
          </code>
          </div>
        </li>
        <li><b>Event Binding</b>: It allows you to listen to events raised by the user in the view, Eg: Click event.
          <div class="code">
            <code class="!whitespace-pre hljs language-html">
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"onButtonClick()"</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          </code>
          </div>
        </li>
        <li><b>Two-way Binding</b>: It combines property binding and event binding, allowing data to flow both ways
          between the component and the view. Two-way binding syntax is a combination of square brackets and parentheses
          [()].
          <div class="code">
            <code class="!whitespace-pre hljs language-html">
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"name"</span>&gt;</span>
            </code>

          </div>
          <br>
          Eg: app-sizer [(size)]="fontSizePx">/app-sizer>
        </li>
        <li>
          <b>Attribute Binding</b>: Attribute binding allows you to dynamically set an element's attribute value based
          on the component's data. It is denoted by the attr. prefix.
          <div class="code">
            <code class="!whitespace-pre hljs language-html">
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">attr.role</span>]=<span class="hljs-string">"isAdmin ? 'admin' : 'user'"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          </code>
          </div>
        </li>
        <li>
          <b>Class Binding</b>: Class binding allows you to add or remove CSS classes dynamically based on the
          component's data. It is denoted by the class. prefix.
          <div class="code">
            <code class="!whitespace-pre hljs language-html">
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">class.error</span>]=<span class="hljs-string">"isError"</span>&gt;</span>Error message<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            </code>
          </div>
        </li>
      </ul>

    </div>

    <div id="27" class="con">
      <h2>Routes</h2>
      <p>Routes are used to define navigation paths within an application. Angular's Router module provides a
        powerful way to manage navigation and map URLs to specific components.<br><br>
        Here's a basic overview of how routes work in Angular:</p><br>

      <p>1. <b>Setting Up Routes</b>: First, you need to set up routes for your application. This is typically done in
        the AppRoutingModule or directly in the AppModule. You define routes using the RouterModule.forRoot() method in
        your NgModule imports. Each route consists of a path and the component that should be displayed when that path
        is matched.</p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
    <span class="hljs-keyword">import</span> { <span class="hljs-title class_">NgModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
    <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Routes</span>, <span class="hljs-title class_">RouterModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;
    <span class="hljs-keyword">import</span> { <span class="hljs-title class_">HomeComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./home.component'</span>;
    <span class="hljs-keyword">import</span> { <span class="hljs-title class_">AboutComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./about.component'</span>;
          
    <span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">Routes</span> = [
        { <span class="hljs-attr">path</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">HomeComponent</span> },
        { <span class="hljs-attr">path</span>: <span class="hljs-string">'about'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">AboutComponent</span> }
        ];
          
    <span class="hljs-meta">@NgModule</span>({
        <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">RouterModule</span>.<span class="hljs-title function_">forRoot</span>(routes)],
            <span class="hljs-attr">exports</span>: [<span class="hljs-title class_">RouterModule</span>]
        })
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppRoutingModule</span> { }
          </code>
      </div>
      <br>
      <p>2. <b>Router Outlet</b>: In your main template file (app.component.html by default), you'll use the
        "router-outlet> /router-outlet>"
        directive. This acts as a placeholder where Angular will render the component associated with the current route.
      </p>
      <div class="code">
        <code class="!whitespace-pre hljs language-html">
          <span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span>
        </code>
      </div><br>

      <p>3. <b>Navigation</b>: You can navigate between routes using the RouterLink directive in your templates or
        programmatically using the Router service.</p>
      <div class="code">
        <code class="!whitespace-pre hljs language-html">
        <span class="hljs-comment">&lt;!-- Using RouterLink directive -- In HTML&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/"</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/about"</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
            </code>
      </div>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
      <span class="hljs-comment">// Using Router service programmatically</span>
      <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Router</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;
          
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> router: Router</span>) {}
          
      <span class="hljs-title function_">goToAboutPage</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-title function_">navigate</span>([<span class="hljs-string">'/about'</span>]);
      }
          </code>
      </div>
      <p><b>Route Parameters</b>: Routes can also contain parameters which allow you to pass data between different
        components. Parameters are defined in the route path using the : prefix.</p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
      <span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">Routes</span> = [
          { <span class="hljs-attr">path</span>: <span class="hljs-string">'product/:id'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">ProductComponent</span> }
      ];
          </code>
      </div>
      <br>
      <p>You can then access the parameter value in your component using the ActivatedRoute service.</p>
      <br>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
    <span class="hljs-keyword">import</span> { <span class="hljs-title class_">ActivatedRoute</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> route: ActivatedRoute</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">route</span>.<span class="hljs-property">params</span>.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">params</span> =&gt;</span> {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params[<span class="hljs-string">'id'</span>]);
        });
    }
          </code>
      </div><br>
      <p>These are the basic concepts of routing in Angular. As your application grows, you may explore more advanced
        features such as child routes, route guards, lazy loading, and so on, to manage complex navigation scenarios
        effectively.</p>
    </div>

    <div id="28" class="con">
      <h2>Hoisting</h2>
      <p>Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their
        containing scope during the compile phase before the code execution. This means that regardless of where
        variables and functions are declared within their scope, they are treated as if they were declared at the top.
        However, only the declarations are hoisted, not the initializations or assignments.</p>
    </div>

    <div id="29" class="con">
      <h2>Loops</h2>
      <ul>
        <li>for - loops through a block of code a number of times</li>
        <li>for/in - loops through the properties of an object</li>
        <li>for/of - loops through the values of an iterable object</li>
        <li>while - loops through a block of code while a specified condition is true</li>
        <li>do/while - also loops through a block of code while a specified condition is true</li>
      </ul>

      <b>while loop</b>
      <div class="code">
        let i = 0;<br>
        while (i'<'5) { <br>
          console.log(i); <span class="comment">// Output: 0, 1, 2, 3, 4</span> <br>
          i++; <br>
          }
      </div>

      <b>'do-while' Loop</b>
      <div class="code">
        let i = 0;<br>
        do {<br>
        console.log(i); <span class="comment">// Output: 0, 1, 2, 3, 4</span> <br>
        i++;<br>
        } while (i '<' 5); </div>


          <b>'for...of' Loop</b>
          <div class="code">
            const numbers = [1, 2, 3, 4, 5];<br>
            for (const num of numbers) {<br>
            console.log(num); <span class="comment">// Output: 0, 1, 2, 3, 4, 5</span><br>
            }<br>
          </div>
      </div>

      <div id="30" class="con">
        <h2>Tricky Questions</h2>
        <div class="code">
          <code class="!whitespace-pre hljs language-javascript">
    <span class="hljs-title class_">Number</span>(<span class="hljs-string">" 123 "</span>); <span class="hljs-comment">// 123;</span>
    <span class="hljs-title class_">Number</span>(<span class="hljs-string">"123z"</span>); <span class="hljs-comment">// NaN (error reading a number at "z");</span>
    <span class="hljs-title class_">Number</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 1;</span>
    <span class="hljs-title class_">Number</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 0;</span>
    <span class="hljs-title class_">Boolean</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// true;</span>
    <span class="hljs-title class_">Boolean</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// false;</span>
    <span class="hljs-title class_">Boolean</span>(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">// true;</span>
    <span class="hljs-title class_">Boolean</span>(<span class="hljs-string">""</span>); <span class="hljs-comment">// false;</span>
    <span class="hljs-title class_">Boolean</span>(<span class="hljs-string">"0"</span>); <span class="hljs-comment">// true;</span>
    <span class="hljs-title class_">Boolean</span>(<span class="hljs-string">" "</span>); <span class="hljs-comment">// true;</span>
    
    <span class="hljs-number">6</span> - <span class="hljs-string">'2'</span>; <span class="hljs-comment">// 4;</span>
    <span class="hljs-string">'6'</span> / <span class="hljs-string">'2'</span>; <span class="hljs-comment">// 3;</span>
    
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> c = ++a;
    <span class="hljs-keyword">let</span> d = b++;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c, d, b); <span class="hljs-comment">// 2 1 2;</span>
            
    <span class="hljs-string">""</span> + <span class="hljs-number">1</span> + <span class="hljs-number">0</span>; 
    <span class="hljs-comment">// "10" // The addition with a string "" + 1 converts 1 to a string: "" + 1 = "1", 
      and then we have "1" + 0, the same rule is applied;</span>
    <span class="hljs-string">""</span> - <span class="hljs-number">1</span> + <span class="hljs-number">0</span>; <span class="hljs-comment">// -1 
      // The subtraction - (like most math operations) only works with numbers, it converts an</span>
    <span class="hljs-comment">// empty string "" to 0;</span>
    
    <span class="hljs-literal">true</span> + <span class="hljs-literal">false</span>; <span class="hljs-comment">// 1;</span>
    <span class="hljs-number">6</span> / <span class="hljs-string">"3"</span>; <span class="hljs-comment">// 2;</span>
    <span class="hljs-string">"2"</span> * <span class="hljs-string">"3"</span>; <span class="hljs-comment">// 6;</span>
    <span class="hljs-number">4</span> + <span class="hljs-number">5</span> + <span class="hljs-string">"px"</span>; <span class="hljs-comment">// "9px";</span>
    <span class="hljs-string">"$"</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span>; <span class="hljs-comment">// "$45";</span>
    <span class="hljs-string">"4"</span> - <span class="hljs-number">2</span>; <span class="hljs-comment">// 2;</span>
    <span class="hljs-string">"4px"</span> - <span class="hljs-number">2</span>; <span class="hljs-comment">// NaN;</span>
    
    <span class="hljs-string">" -9 "</span> + <span class="hljs-number">5</span>; <span class="hljs-comment">// " -9 5" </span> 
    <span class="hljs-comment">// The addition with a string appends the number 5 to the string.</span>
    
    <span class="hljs-string">" -9 "</span> - <span class="hljs-number">5</span>; <span class="hljs-comment">// -14 </span>
    <span class="hljs-comment">// The subtraction always converts to numbers, so it makes " -9 " a number -9</span>
    
    <span class="hljs-literal">null</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 1 </span>
    <span class="hljs-comment">// null becomes 0 after the numeric conversion.</span>
    
    <span class="hljs-literal">undefined</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// NaN </span>
    <span class="hljs-comment">// undefined becomes NaN after the numeric conversion.</span>
    
    <span class="hljs-string">" \t \n"</span> - <span class="hljs-number">2</span>; <span class="hljs-comment">// -2 </span>
    <span class="hljs-comment">// Space characters are trimmed off string start and end when a string is converted to a</span>
    <span class="hljs-comment">// number. Here the whole string consists of space characters, such as \t, \n and a â€œregularâ€ space between</span>
    <span class="hljs-comment">// them. So, similarly to an empty string, it becomes 0.</span>
      </code>
        </div>

      </div>
      <div id="31" class="con">
        <h2>Array Methods</h2>
        <p>1. <b>push()</b>: Adds one or more elements to the end of an array and returns the new length of the array.

        <div class="code">
          <code class="!whitespace-pre hljs language-javascript">
            <span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>];
              fruits.<span class="hljs-title function_">push</span>(<span class="hljs-string">'orange'</span>);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits); <span class="hljs-comment">// Output: ['apple', 'banana', 'orange']</span>
            </code>
        </div>
        </p><br>
        <p>2. <b>pop()</b>: Removes the last element from an array and returns that element.
        <div class="code">
          <code class="!whitespace-pre hljs language-javascript">
          <span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>];
          <span class="hljs-keyword">let</span> lastFruit = fruits.<span class="hljs-title function_">pop</span>();
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lastFruit); <span class="hljs-comment">// Output: 'orange'</span>
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits); <span class="hljs-comment">// Output: ['apple', 'banana']</span>
          </code>
        </div>
        </p><br>
        <p>3. <b>unshift()</b>: Adds one or more elements to the beginning of an array and returns the new length of the
          array.
        <div class="code">
          <code class="!whitespace-pre hljs language-javascript">
          <span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>];
            fruits.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">'apple'</span>);
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits); <span class="hljs-comment">// Output: ['apple', 'banana', 'orange']</span>
          </code>
        </div>
        </p><br>
        <p>4. <b>forEach()</b>: Executes a provided function once for each array element.
        <div class="code">
          <code class="!whitespace-pre hljs language-javascript">
          <span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
            numbers.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">number</span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(number * <span class="hljs-number">2</span>);
            });
          <span class="hljs-comment">// Output:</span>
          <span class="hljs-comment">// 2</span>
          <span class="hljs-comment">// 4</span>
          <span class="hljs-comment">// 6</span>
          <span class="hljs-comment">// 8</span>
          </code>
        </div>
        </p><br>
        <p>5. <b>map()</b>: Creates a new array populated with the results of calling a provided function on every
          element in the calling array.

        <div class="code">
          <code class="!whitespace-pre hljs language-javascript">
          <span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
          <span class="hljs-keyword">let</span> doubledNumbers = numbers.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">number</span>) {
              <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>;
            });
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doubledNumbers); <span class="hljs-comment">// Output: [2, 4, 6, 8]</span>
          </code>
        </div>
        </p><br>
        <p>6. <b>filter()</b>: Creates a new array with all elements that pass the test implemented by the provided
          function.
        <div class="code">
          <code class="!whitespace-pre hljs language-javascript">
          <span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
          <span class="hljs-keyword">let</span> evenNumbers = numbers.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">number</span>) {
            <span class="hljs-keyword">return</span> number % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;
          });
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(evenNumbers); <span class="hljs-comment">// Output: [2, 4]</span>
          </code>
        </div>
        </p><br>
        <p>7. <b>shift()</b>: Removes the first element from an array and returns that element.
        <div class="code">
          <code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>];
          <span class="hljs-keyword">let</span> firstFruit = fruits.<span class="hljs-title function_">shift</span>();
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstFruit); <span class="hljs-comment">// Output: 'apple'</span>
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits); <span class="hljs-comment">// Output: ['banana', 'orange']</span>
          </code>
        </div>
        </p><br>
        <p>8. <b>slice()</b>: The slice() method is used to extract a section of an array and return a new array without
          modifying the original array. It takes two optional parameters: start and end, which specify the beginning and
          end of the extracted portion of the array.
        <div class="code">
          <code class="!whitespace-pre hljs language-javascript">
          <span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'grape'</span>, <span class="hljs-string">'kiwi'</span>];

          <span class="hljs-comment">// Extract elements from index 1 to index 3 (not including 3)</span>
          <span class="hljs-keyword">let</span> slicedFruits = fruits.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(slicedFruits); <span class="hljs-comment">// Output: ['banana', 'orange']</span>
            
          <span class="hljs-comment">// Extract elements from index 2 to the end of the array</span>
          <span class="hljs-keyword">let</span> slicedFruits2 = fruits.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(slicedFruits2); <span class="hljs-comment">// Output: ['orange', 'grape', 'kiwi']</span>
            
          <span class="hljs-comment">// Original array remains unchanged</span>
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits); <span class="hljs-comment">// Output: ['apple', 'banana', 'orange', 'grape', 'kiwi']</span>
          </code>
        </div>
        </p><br>
        <p><b>splice()</b>: The splice() method in JavaScript is used to change the contents of an array by removing or
          replacing existing elements and/or adding new elements in place. It modifies the original array.

        <div class="code">
          <code class="!whitespace-pre hljs language-javascript">
          <span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'grape'</span>, <span class="hljs-string">'kiwi'</span>];

          <span class="hljs-comment">// Remove 'orange' from the array</span>
            fruits.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits); <span class="hljs-comment">// Output: ['apple', 'banana', 'grape', 'kiwi']</span>
            
          <span class="hljs-comment">// Remove 'banana' and 'grape', and add 'lemon' and 'peach' starting from index 1</span>
            fruits.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'lemon'</span>, <span class="hljs-string">'peach'</span>);
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits); <span class="hljs-comment">// Output: ['apple', 'lemon', 'peach', 'kiwi']</span>
            
          <span class="hljs-comment">// Add 'pear' and 'orange' starting from index 2 without removing any elements</span>
            fruits.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'pear'</span>, <span class="hljs-string">'orange'</span>);
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits); <span class="hljs-comment">// Output: ['apple', 'lemon', 'pear', 'orange', 'peach', 'kiwi']</span>
          </code>
        </div>
        </p><br>
        <p><b>reduce()</b>: The reduce() method in JavaScript is used to apply a function to each element in the array
          to reduce the array to a single value. It iterates through the array from left to right, accumulating a single
          result by calling the provided function with an accumulator and each element in the array.

        <div class="code">
          <code class="!whitespace-pre hljs language-javascript">
          <span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];

          <span class="hljs-comment">// Calculate the sum of all numbers in the array</span>
          <span class="hljs-keyword">let</span> sum = numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, currentValue</span>) {
            <span class="hljs-keyword">return</span> accumulator + currentValue;
          }, <span class="hljs-number">0</span>); <span class="hljs-comment">// Initial value of accumulator is 0</span>
            
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum); <span class="hljs-comment">// Output: 15 (1 + 2 + 3 + 4 + 5)</span>
          </code>
        </div>
        </p>
      </div>


      <div id="32" class="con">
        <h2>Unit Testing - Jasmin</h2>
        <p>
          <b>Setup</b>
          : Angular CLI automatically generates a testing setup when you create a new Angular project. You'll find
          configuration files for Karma (test runner) and Jasmine in the karma.conf.js and src/test.ts files
          respectively.<br><br>

          <b>Writing Tests</b>: Tests are typically written in .spec.ts files alongside the components, services, or
          other units
          being tested. You can place them in the same directory as the file being tested or in a spec
          directory.<br><br>

          <b>Describe and It</b>: Jasmine provides functions describe() and it() to structure your tests. describe() is
          used to
          group related tests, and it() is used to define individual test cases.<br><br>

          <b>Expectations</b>: Jasmine provides a set of functions like expect() to define expectations or assertions.
          You can
          use matchers like toEqual(), toBeTruthy(), toContain(), etc., to check the expected behavior of your
          code.<br><br>

          <b>Setup and Teardown</b>: Jasmine provides beforeEach() and afterEach() functions to set up and tear down
          test
          fixtures respectively. You can also use beforeAll() and afterAll() for setup and teardown that should run once
          for the entire test suite.<br><br>

          <b>Spies and Mocks</b>: Jasmine provides spies for spying on function calls and tracking calls to those
          functions.
          Spies can also be used to mock dependencies and control their behavior during tests.<br><br>

          <b>Async Testing</b>: Angular often involves asynchronous operations such as HTTP requests or timeouts.
          Jasmine
          provides mechanisms for handling asynchronous code using functions like async(), fakeAsync(), and
          tick().<br><br>

          <b>Angular Testing Utilities</b>: Angular provides additional utilities for testing Angular-specific features
          such as
          TestBed for configuring and creating components with their dependencies, ComponentFixture for interacting with
          component instances, and so on.
        </p><br>


        <div class="code">
          <code class="!whitespace-pre hljs language-typescript">
      <span class="hljs-keyword">import</span> { <span class="hljs-title class_">TestBed</span>, <span class="hljs-title class_">ComponentFixture</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core/testing'</span>;
      <span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.component'</span>;
            
      <span class="hljs-title function_">describe</span>(<span class="hljs-string">'AppComponent'</span>, <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-keyword">let</span> <span class="hljs-attr">component</span>: <span class="hljs-title class_">AppComponent</span>;
          <span class="hljs-keyword">let</span> <span class="hljs-attr">fixture</span>: <span class="hljs-title class_">ComponentFixture</span>&lt;<span class="hljs-title class_">AppComponent</span>&gt;;
            
          <span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">async</span> () =&gt; {
            <span class="hljs-keyword">await</span> <span class="hljs-title class_">TestBed</span>.<span class="hljs-title function_">configureTestingModule</span>({
                  <span class="hljs-attr">declarations</span>: [
                    <span class="hljs-title class_">AppComponent</span>
              ],
            }).<span class="hljs-title function_">compileComponents</span>();
          });
            
          <span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">() =&gt;</span> {
                fixture = <span class="hljs-title class_">TestBed</span>.<span class="hljs-title function_">createComponent</span>(<span class="hljs-title class_">AppComponent</span>);
                component = fixture.<span class="hljs-property">componentInstance</span>;
                fixture.<span class="hljs-title function_">detectChanges</span>();
          });
            
          <span class="hljs-title function_">it</span>(<span class="hljs-string">'should create the app'</span>, <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-title function_">expect</span>(component).<span class="hljs-title function_">toBeTruthy</span>();
          });
            
          <span class="hljs-title function_">it</span>(<span class="hljs-string">`should have as title 'my-app'`</span>, <span class="hljs-function">() =&gt;</span> {
                <span class="hljs-title function_">expect</span>(component.<span class="hljs-property">title</span>).<span class="hljs-title function_">toEqual</span>(<span class="hljs-string">'my-app'</span>);
          });
            
          <span class="hljs-title function_">it</span>(<span class="hljs-string">'should render title'</span>, <span class="hljs-function">() =&gt;</span> {
                <span class="hljs-keyword">const</span> compiled = fixture.<span class="hljs-property">nativeElement</span>;
                <span class="hljs-title function_">expect</span>(compiled.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'.content span'</span>).<span class="hljs-property">textContent</span>).<span class="hljs-title function_">toContain</span>(<span class="hljs-string">'my-app app is running!'</span>);
          });
        });
            </code>
        </div>
      </div>

      <div id="33" class="con">
        <h2>of & from Operator</h2>
        <p><b>of</b>: The "of" operator creates an observable from the agruments that we pass into it. You can pass any
          number of arguments to the "of" operator.</p><br>
        <p>Each argument is emitted seperatly one after another. It sends the complete signal in the end.</p>
        <div class="code">
          <code class="!whitespace-pre hljs language-typescript">
        <span class="hljs-comment">// of Operator example</span>

        <span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>[] = [];
        array1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
        array2 = [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>];
            
        myOfObservableOperator = <span class="hljs-title function_">of</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">array1</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">array2</span>);
            
        getOfOperator = <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = [];
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">myOfObservableOperator</span>.<span class="hljs-title function_">subscribe</span>({
            <span class="hljs-attr">next</span>: <span class="hljs-function">(<span class="hljs-params">val: <span class="hljs-built_in">any</span></span>) =&gt;</span> { <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">push</span>(val); },
            <span class="hljs-attr">error</span>: <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> { <span class="hljs-title function_">alert</span>(err.<span class="hljs-property">message</span>); },
            <span class="hljs-attr">complete</span>: <span class="hljs-function">() =&gt;</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Completed!!'</span>); }
          });
        };
            
        <span class="hljs-comment">// In HTML page</span>
            
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"getOfOperator()"</span>&gt;</span>Get of Operator<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"data-list"</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let x of data"</span>&gt;</span>
          {{x}}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
            </code>

        </div>
        <br>
        <p><b>from</b>: The "from" operator takes a single argument which can be iterated over and converts it into an
          observable. <br>
          <u>If you want to convert Promise into an observable, then the "from" operator is the best way todo that. </u>
        </p>
        <div class="code">
          <code class="!whitespace-pre hljs language-typescript">
      <span class="hljs-comment">// from Operator example</span>

      namearr = <span class="hljs-string">'TonuRishabhRaj'</span>;
      <span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>[] = [];
            
      promiseData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-title function_">resolve</span>([<span class="hljs-number">12</span>, <span class="hljs-number">14</span>, <span class="hljs-number">34</span>, <span class="hljs-number">23</span>, <span class="hljs-number">45</span>]);
      });
            
      <span class="hljs-comment">// myfromOperator = from(this.namearr);</span>
      myfromOperator = <span class="hljs-title function_">from</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">promiseData</span>);
            
      getfromOperator = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = [];
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">myfromOperator</span>.<span class="hljs-title function_">subscribe</span>({
          <span class="hljs-attr">next</span>: <span class="hljs-function">(<span class="hljs-params">val: <span class="hljs-built_in">any</span></span>) =&gt;</span> { <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">push</span>(val); },
          <span class="hljs-attr">error</span>: <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>); },
          <span class="hljs-attr">complete</span>: <span class="hljs-function">() =&gt;</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Completed"</span>); }
        });
      };
            </code>
        </div>
      </div>

      <div id="34" class="con">
        <h2>Property Binding</h2>
        <b>Passing data as an object</b>
        <p>In this example, ItemListComponent is a child component of AppComponent and the items property expects an
          array of objects.</p>
        <div class="code">
          <code class="!whitespace-pre hljs language-typescript"><span class="hljs-comment">// Inside the child component, the ItemListComponent </span>
  <span class="hljs-comment">// src/app/item-list.component.ts</span>
  <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Input</span>, <span class="hljs-title class_">Output</span>, <span class="hljs-title class_">EventEmitter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
            
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemOutputComponent</span> {
  <span class="hljs-meta">@Input</span>() <span class="hljs-attr">items</span>: <span class="hljs-title class_">Item</span>[] = [];  
  <span class="hljs-meta">@Output</span>() newItemEvent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>&lt;<span class="hljs-built_in">string</span>&gt;();
            
  <span class="hljs-title function_">addNewItem</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">newItemEvent</span>.<span class="hljs-title function_">emit</span>(value);
  }
}
            
  <span class="hljs-comment">// Inside child template (html page)</span>
  &lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">"item-input"</span>&gt;<span class="hljs-title class_">Add</span> an <span class="hljs-attr">item</span>:&lt;/label&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"item-input"</span> #<span class="hljs-attr">newItem</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"addNewItem(newItem.value)"</span>&gt;</span>Add to parent's list<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

  <span class="hljs-comment">// Inside App component</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppComponent</span> {
  items = [<span class="hljs-string">'item1'</span>, <span class="hljs-string">'item2'</span>, <span class="hljs-string">'item3'</span>, <span class="hljs-string">'item4'</span>];
            
  <span class="hljs-title function_">addItem</span>(<span class="hljs-params">newItem: <span class="hljs-built_in">string</span></span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(newItem);
    }
  }
            
  <span class="hljs-comment">// Inside parent template (app.component.html)</span>
  &lt;app-item-output 
  [items]=<span class="hljs-string">"currentItem"</span> 
  (newItemEvent)=<span class="hljs-string">"addItem($event)"</span>&gt;&lt;/app-item-output&gt;
          </code>
        </div>
      </div>

      <div id="35" class="con">
        <h2>HostListener</h2>
        <p>The @HostListener decorator listens to the DOM event on the host element and it reacts to that event by
          executing an event handler method.</p>
        <div class="code">
          <code class="!whitespace-pre hljs language-typescript">
  <span class="hljs-comment">// Create a custom directive to hover effect on HTML element</span>
  <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Directive</span>, <span class="hljs-title class_">ElementRef</span>, <span class="hljs-title class_">HostListener</span>, <span class="hljs-title class_">Renderer2</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
              
  <span class="hljs-meta">@Directive</span>({
    <span class="hljs-attr">selector</span>: <span class="hljs-string">'[appHover]'</span>
  })
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HoverDirective</span> {
              
  <span class="hljs-comment">// When we use the private keyword with the parameters, 
    Angular creates a private property with that name behind the scenes and assigns that 
    private property with that parameter.</span>
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> element: ElementRef, <span class="hljs-keyword">private</span> renderer: Renderer2</span>) { }
              
    <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">'mouseenter'</span>) <span class="hljs-title function_">onmouseOver</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderer</span>.<span class="hljs-title function_">setStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-property">nativeElement</span>, <span class="hljs-string">'margin'</span>, <span class="hljs-string">'5px 10px'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderer</span>.<span class="hljs-title function_">setStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-property">nativeElement</span>, <span class="hljs-string">'padding'</span>, <span class="hljs-string">'30px 30px'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderer</span>.<span class="hljs-title function_">setStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-property">nativeElement</span>, <span class="hljs-string">'background-color'</span>, <span class="hljs-string">'#e3685e'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderer</span>.<span class="hljs-title function_">setStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-property">nativeElement</span>, <span class="hljs-string">'transition'</span>, <span class="hljs-string">'0.5s'</span>);
    }
              
    <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">'mouseleave'</span>) <span class="hljs-title function_">onmouseOut</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderer</span>.<span class="hljs-title function_">setStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-property">nativeElement</span>, <span class="hljs-string">'margin'</span>, <span class="hljs-string">'10px 20px'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderer</span>.<span class="hljs-title function_">setStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-property">nativeElement</span>, <span class="hljs-string">'padding'</span>, <span class="hljs-string">'10px 20px'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderer</span>.<span class="hljs-title function_">setStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-property">nativeElement</span>, <span class="hljs-string">'background-color'</span>, <span class="hljs-string">'#d2691e'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderer</span>.<span class="hljs-title function_">setStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-property">nativeElement</span>, <span class="hljs-string">'transition'</span>, <span class="hljs-string">'0.5s'</span>);
      }
    }
              </code>
        </div>

        <div class="code">
          <code class="!whitespace-pre hljs language-html">
    <span class="hljs-comment">&lt;!-- In app.component.html --&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span> <span class="hljs-attr">appHover</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Custom attribute directive for @HostListener<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span> <span class="hljs-attr">appHover</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Custom attribute directive for @HostListener<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            </code>
        </div>

      </div>

      <div id="36" class="con">
        <h2>HostBinding</h2>
        <p>The @HostBinding decorator binds a host element property to a variable in a directive or a component.</p>

        <div class="code">
          <code class="!whitespace-pre hljs language-typescript">
    <span class="hljs-comment">// Create a custom directive</span>
    <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Directive</span>, <span class="hljs-title class_">ElementRef</span>, <span class="hljs-title class_">HostBinding</span>, <span class="hljs-title class_">HostListener</span>, <span class="hljs-title class_">Renderer2</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
            
    <span class="hljs-meta">@Directive</span>({
      <span class="hljs-attr">selector</span>: <span class="hljs-string">'[appHighlight]'</span>
    })
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HighlightDirective</span> {
            
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> element: ElementRef, <span class="hljs-keyword">private</span> renderer: Renderer2</span>) { }
            
      <span class="hljs-comment">// Create a property for a highlight directive class</span>
      <span class="hljs-meta">@HostBinding</span>(<span class="hljs-string">'style.backgroundColor'</span>) <span class="hljs-attr">background</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">'#749fef'</span>;
            
      <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">'mouseenter'</span>) <span class="hljs-title function_">mouseOver</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">background</span> = <span class="hljs-string">'#cbc519'</span>;
      }
            
      <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">'mouseleave'</span>) <span class="hljs-title function_">mouseOut</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">background</span> = <span class="hljs-string">'#749fef'</span>;
      }
    }
            </code>
        </div>

        <div class="code">
          <code class="!whitespace-pre hljs language-html">
    <span class="hljs-comment">&lt;!-- In app.component.html --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span> <span class="hljs-attr">appHighlight</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Custom attribute directive for @HostBinding<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            </code>
        </div>

      </div>

      <div id="37" class="con">
        <h2>..</h2>
        <p></p>
      </div>


      <div class="end"></div>
</body>

</html>