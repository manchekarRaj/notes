<!DOCTYPE html>

<head>
  <style>
    body {
      font-family: Verdana, Geneva, Tahoma, sans-serif;
      font-size: large;
      background-color: rgb(28, 28, 28);
      color: rgb(226, 234, 241);
    }

    .code {
      font-family: "Consolas";
      font-style: italic;
      color: rgb(132, 219, 2);
      border: 1px;
      border-style: inset;
      padding: 2px;
      margin: 5px;
      width: 98%;
    }

    .con {
      border: 2px;
      border-style: double;
      padding: 5px;
      margin: 5px;
      width: 98%;
    }

    .comment {
      font-size: medium;
      font-style: italic;
      color: rgb(112, 111, 111);
    }

    h2 {
      color: rgb(72, 176, 245);
    }

    h4 {
      color: rgb(71, 144, 177);
      font-style: italic;
    }

    li {
      color: rgb(234, 225, 98);
    }

    u {
      color: rgb(0, 221, 203);
    }

    .cmd {
      color: rgb(124, 255, 141);
      font-family: 'Courier New', Courier, monospace;
    }

    b {
      color: rgb(255, 226, 61);
    }

    .keyword {
      color: rgb(93, 190, 255);
    }

    .class {
      color: rgb(255, 61, 77);
    }
  </style>

</head>

<body>
  <div id="1" class="con">
    <h2>Setup</h2>
    <p>Angular is an application-design framework and development platform for creating efficient and sophisticated
      single-page apps.</p>
    <ul>
      <li>To install the Angular CLI > <span class="cmd">npm install -g @angular/cli</span></li>
      <li>To create a new workspace > <span class="cmd">ng new my-app</span></li>
      <li>Run the application > <span class="cmd">ng serve</span></li>
    </ul>

  </div>

  <div id="2" class="con">
    <h2>Components</h2>
    <p>Components are the main building blocks for Angular applications. Each component consists of:</p>
    <ul>
      <li>An HTML template that declares what renders on the page</li>
      <li>A TypeScript class that defines behavior</li>
      <li>A CSS selector that defines how the component is used in a template</li>
    </ul>
    <p>Generate component</p>
    <ul>
      <li><span class="cmd">ng generate component [name]</span></li>
    </ul>
    <p>Component Lifecycle</p>
    <ul>
      <li>The component's lifecycle starts when Angular initializes the component, Then the component changes as per
        change detection, and the lifecycle ends when Angular destroys the component instance and removes its from the
        DOM.</li>
    </ul>
    <p>Component Lifecycle Hooks</p>
    <ul>
      <li><u>ngOnChanges</u> - When an input or output binding value changes.</li>
      <li><u>ngOnInit</u> - After the first ngOnChanges.</li>
      <li><u>ngDoCheck</u> - Developer's custom change detection.</li>
      <li><u>ngOnDestroy</u> - Just before the directive is destroyed.</li>
    </ul>
    <p>Sharing data between child and parent directives and components</p>
    <ul>
      <li>'@'Input() and Output() decorators give a child component a way to communicate with its parent component.</li>
      <li>'@'Input() decorator, data flows from parent to child, To use Input() decorator, you must configure both
        parent and child.</li>
      <li>'@'Output() decorator, the data flow from the child to the parent component.</li>
      <li>Use EventEmitter class to while using '@'Output() decorator</li>
      <li><span class="cmd">'@'Output() newItemEvent = new EventEmitter<string>();</span></li>
      <li><span class="cmd">this.newItemEvent.emit(value);</span></li>
    </ul>

    <p>Use '@'Input() and '@'Output() on the same child component as follows:</p>
    <ul>
      <li><span class="cmd">child-component [item]="currentItem" (deleteRequest)="crossOffItem($event)"
          /child-component</span></li>
    </ul>

  </div>

  <div id="3" class="con">
    <h2>Templates</h2>
    <p>In Angular, a template is a blueprint for a fragment of a user interface (UI), written in HTML, and syntax</p>

    <p>Templates syntax</p>
    <ul>
      <li><u>Interpolation</u> - Uses the double curly braces <span class="cmd">{{ and }}</span> as delimiters.</li>
      <li><u>Property binding</u> - In property binding you set values for properties of HTML elements or directives.
      </li>
      <li>Eg, img tag: <span class="cmd">img alt="item" [src]="itemImageUrl"</span></li>
      <li><u>Event binding</u> - <span class="cmd">button (click)="onSave()" Save /button</span></li>
      <li><u>Attributes</u> - Provides additional information about that particular element. </li>
      <li>Attributes in HTML - src, alt, id, href, style, lang, width, height</li>
      <li><u>Class and style binding</u> - <span class="cmd">nav [style.background-color]="expression"/nav</span></li>
      <li><u>Two-way data binding</u> - <span class="cmd">app-sizer [(size)]="fontSizePx" app-sizer</span></li>
    </ul>
    <br>
  </div>

  <div id="4" class="con">
    <h2>Pipes</h2>
    <p>Pipes are used in the template expressions to transforme the values. </p>
    <ul>
      <li><u>DatePipe</u>: Formats a date value according to locale rules.</li>
      <li><u>CurrencyPipe</u>: Transforms a number to a currency string, formatted according to locale rules.</li>
      <li>LowerCasePipe , UpperCasePipe</li>
      <li><u>AsyncPipe</u>: Subscribe and unsubscribe to an asynchronous source such as an observable.</li>
      <li>The hero's birthday is {{ birthday | date }}</li>
      <li><u>Chained pipes</u>: The hero's birthday is {{ birthday | date | uppercase}}</li>
    </ul>
    <div class="code">
      import { Component } from '@angular/core';<br>
      import { DatePipe } from '@angular/common';<br>
      <br>
      '@'Component({<br>
      standalone: true,<br>
      selector: 'app-birthday',<br>
      templateUrl: './birthday.component.html',<br>
      imports: [DatePipe],<br>
      })<br><br>
      export class BirthdayComponent {<br>
      birthday = new Date(1988, 3, 15); // April 15, 1988 -- since month parameter is zero-based<br>
      }<br>
      <br>
    </div>
    <br>

    <h3>Custom Pipe</h3>

    <div class="code">

      <span class="keyword">import</span> { <span class="keyword">Pipe, PipeTransform</span> } <span
        class="keyword">from</span> '@angular/core';
      <br>
      '@'Pipe({<br>
      name: 'custom'<br>
      })<br>
      <span class="keyword">export class</span> <span class="class">CustomPipe</span> <span
        class="keyword">implements</span> <span class="class">PipeTransform</span> {<br>
      transform(value: any): any {<br>
      return value * 2;<br>
      }<br>
      }<br>

      <span class="comment">import and declare your custom pipe in app.module.ts</span>

      <div class="code">
        import { NgModule } from '@angular/core';<br>
        import { BrowserModule } from '@angular/platform-browser';<br>
        <span class="keyword">import</span> {<span class="class">CustomPipe</span>} <span class="keyword">from</span>
        './custom.pipe'; <span class="comment">// Import your custom pipe</span><br>
        <br>
        '@'NgModule({<br>
        declarations: [<br>
        CustomPipe <span class="comment">// Declare your custom pipe here</span><br>
        ],<br>
        imports: [<br>
        BrowserModule<br>
        ],<br>
        bootstrap: [],<br>
        })<br>
        export class AppModule { }<br>
      </div>



      </app>

    </div>
  </div>

  <div id="5" class="con">
    <h2>Directives</h2>
    <p>Directives are classes that add additional behavior to the elements in your Angular applications.</p>
    <ul>
      <li>Components - </li>
      <li>Attribute directives - Change the appearance or behavior of DOM elements<br>
        - <u>NgClass</u>: Adds and removes a set of CSS classes.<br>
        - <u>NgStyle</u>: Adds and removes a set of HTML styles.<br>
        - <u>NgModel</u>: Adds two-way data binding to an HTML form element.<br>
      </li>
      <li>Structural directives - Change the DOM layout by adding and removing DOM elements.<br>
        - <u>NgIf</u>: Adds and removes a set of CSS classes.<br>
        - <u>NgFor</u>: Adds and removes a set of HTML styles.<br>
      </li>
    </ul>

  </div>

  <div id="6" class="con">
    <h2>Dependency Injection</h2>
    <p>When you develop a smaller part of your system, like a module or a class, you may need to use features from other
      classes. For example, you may need an HTTP service to make backend calls. Dependency Injection, or DI, is a design
      pattern and mechanism for creating and delivering some parts of an application to other parts of an application
      that require them. Angular supports this design pattern and you can use it in your applications to increase
      flexibility and modularity.</p>
    <ul>
      <li>'@'Injectable() - The first step is to add the @Injectable decorator to show that the class can be injected.
      </li>
      <li>constructor(private service: HeroService) {} - The most common way to inject a dependency is to declare it in
        a class constructor.</li>
    </ul>
    <p>Hierarchical injectors</p>
    <ul>
      <li>In Hierarchical injectors, you can determine whether to declare a provider at the application level, in a
        Component, or in a Directive</li>
    </ul>

  </div>

  <div id="7" class="con">
    <h2>Best Practices</h2>
    <ul>
      <li><u>Security</u>: Security against cross-site scripting attacks</li>
      <li><u>Accessibility</u>: For people with visual or motor impairements</li>
      <li><u>Keeping up-to-date</u>: To optamize your application there is one way you can do is to keep your
        application
        up-to-date</li>
      <li><u>Property binding best practices</u>: Avoid side effects?????
      </li>
      <li><u>Lazy-loading</u>: By default, NgModules are eagerly loaded. So for large applications with lots of routes,
        we can
        consider using lazy loading, this will help to keep the application (bundle) size small, which in turn helps
        decrease load times.</li>
      <li><u>Lightweight injection token pattern for libraries</u>: The lightweight injection token design pattern is
        especially important for library developers. It ensures that when an application uses only some of your
        library's capabilities, the unused code can be eliminated from the client's application bundle???????</li>
    </ul>

    <p>
      Cross-site scripting (XSS) enables attackers to inject malicious code into web pages and then they can steal your
      sensative data like login username/password or perform actions that impersonate the user.<br>
      To block XSS attacks, you must prevent malicious code from entering the Document Object Model (DOM).<br>
      Eg: <span class="cmd"> img alt="" onerror="..."> and a> href="javascript:..."/a> </span>.

    </p>

    <h2>Security Best Practices</h2>
    Most of the time older versions are not maintained, so it's better to migrate to the latest version.<br>
    <br>
    If you are dealing with sensitive data, it is better to use SSL, This technology encrypts data before it is sent
    from the client to the server, thus preventing some common hacks like packet sniffing. TLS is the next level of SSL.
    <br><br>
    Packet sniffing is the process of intercepting the data stream that flows across the network, you can capture each
    packet and, if needed, decode the packet's raw data. This way you can get access to the raw value.
    <br><br>
    You can use Helmet. Helmet helps protect your application by setting HTTP headers appropriately.
    <br><br>
    <ul>
      <li>Content-Security-Policy header. This helps prevent cross-site scripting attacks.</li>
      <li>X-Frame-Options header. This provides clickjacking protection.</li>
      <li> Strict-Transport-Security header. This helps enforce secure (HTTPS) connections to the server.</li>
    </ul>
    <br>

    <b>Clickjacking</b> - When an attacker uses multiple transparent or opaque layers to trick a user into clicking on a
    button
    or link on another page.
    <br><br>
    Helmet is a collection of smaller middleware functions that set security-related HTTP response headers.
    <br><br>
    Security best practices for Express applications in production include:
    <ul>
      <li>Don't use deprecated or vulnerable versions of Express</li>
      <li>Use TLS (Transport Layer Security)</li>
      <li>Use Helmet</li>
      <li>Use cookies securely</li>
      <li>Prevent brute-force attacks against authorization</li>
      <li>Ensure your dependencies are secure</li>
      <li>Avoid other known vulnerabilities</li>
    </ul>


  </div>

  <div id="8" class="con">
    <h2>Interceptor</h2>
    <p>The http Interceptor basically intercepts the outgoing HTTP requests, transforms them and then sends it to the
      server. The Interceptor modifies the request to contain the token that is stored in the browser’s local storage.
    </p>
  </div>


  <div id="9" class="con">
    <h2>Route Guard</h2>
    <p>
      Route guards control the navigation to and from components, it can return true in which case the normal execution
      continues or returns false in which case the navigation is stopped. For routes which needs authentication the
      route guard will return true if the token is present in the browser and return false if the token is absent.<br>

      Just the existence of the token is not important, the token has to be verified through the backend to make sure it
      is valid. To achieve that we can use Angular Interceptor

    </p>
    <div class="code">

    </div>

  </div>

  <div id="10" class="con">
    <h2>Observables & RxJS</h2>
    Observables are used to pass values/data across your application. They are used frequently in Angular and are a
    technique for event handling, asynchronous programming, and handling multiple values.
    <br>

    <b>NOTIFICATION TYPE</b><br>
    <u>next</u>: Required. A handler for each delivered value. Called zero or more times after execution starts.<br>
    <u>error</u>: Optional. A handler for an error notification. An error halts execution of the observable
    instance.<br>
    <u>complete</u>: Optional. A handler for the execution-complete notification. Delayed values can continue to be
    delivered to the next handler after execution is complete.<br>
    For Error handling you use error callbacks on the observer.<br><br>
    <span class="cmd">
      myObservable.subscribe({<br>
      next(num) { console.log('Next num: ' + num)},<br>
      error(err) { console.log('Received an error: ' + err)}<br>
      });<br>
    </span>
    <br>

  </div>

  <div id="11" class="con">
    <h2>Lifecycle hooks</h2>
    <p>An Angular Component goes through different phases right from its creation until it is destroyed.</p>
    <uL>
      <li><u>constructor</u> : This is invoked when Angular creates a component or directive by calling new on the
        class.</li>
      <li><u>ngOnChanges</u>: Invoked every time there is a change in one of the input properties of the component.</li>
      <li><u>ngOnInit</u> : Invoked when a given component has been initialized.
        This hook is only called once after the first ngOnChanges
      </li>
      <li><u>ngDoCheck</u>: Invoked when the change detector of the given component is invoked. It allows us to
        implement our
        own change detection algorithm for the given component.
        Use ngDoCheck when you want to capture changes that Angular otherwise doesn't. For example, if a binding
        reference remains unchanged after a click event, ngOnChanges won't run but ngDoCheck will.
      </li>
      <li><u>ngOnDestroy</u>:This method will be invoked just before Angular destroys the component. Use this hook to
        unsubscribe
        observables and detach event handlers to avoid memory leaks.</li>
      <li><u>ngAfterViewChecked</u>: ngAfterViewChecked is useful when you want to call a lifecycle hook after all child
        components have been initialized and checked.</li>
    </uL>


  </div>

  <div id="12" class="con">
    <h2>Async Pipe</h2>
    <ul>
      <li>The async pipe returns the latest value from a stream of data and continues to do so for the life of a given
        component. When Angular destroys that component, the async pipe automatically stops.</li>
      <li>We are directly using the Observables with the async pipe on the template.</li>
      <li>With an async pipe you can handle asynchronous data in an Angular template.</li>
      <li>Any time you subscribe to an Observable, you need to unsubscribe, otherwise your code would leak and you might
        face unexpected behavior in your application.</li>
      <li>Async pipe handles unsubscription for you.</li>
      <li>The async pipe will trigger change detection when a new value is emitted.</li>
    </ul>

    <span class="cmd">
      {{ greeting | async }} // in template

    </span>
  </div>
  <div id="13" class="con">
    <h2>ViewChild Decorator</h2>
    <uL>
      <li>In Javascript we use document.getElementById('con'), to get a reference of our HTML element, and then with DOM
        methods, we manipulate it.</li>
      <li>In Angular, if you want to get a reference of the element of your template file into the component class, in
        that case, you can use ViewChild or ViewChildern.</li>
      <li>If you need to access references of multiple components then use ViewChildren.</li>
    </uL>

    <span class="cmd">
      // In template <br>
      pane id="1" '*'ngIf="shouldShow">/pane><br>
      pane id="2" '*'ngIf="'!'shouldShow">/pane><br>

      <br>
      // In component <br>
      '@'ViewChild(Pane) <br>
      set pane(v: Pane) { <br>
      setTimeout(() => { <br>
      this.selectedPane = v.id; <br>
      }, 0); <br>
      } <br>



    </span>


  </div>
  <div id="14" class="con">
    <h2>Template variables / Symbol</h2>
    Template variables are used to refer to an HTML element and all of its DOM properties. You use the # symbol followed
    by the variable name.<br>
    <span class="cmd">
      input #myInput type=”text”><br>
      button (click)=”logMessage(myInput.value)”> /button><br>
    </span>
    <p><u>Template variable scope</u>: Refer to a template variable anywhere within its surrounding template. Structural
      directives, such as *ngIf and *ngFor, or /ng-template> act as a template boundary. You cannot access template
      variables outside of these boundaries.
    </p>
  </div>

  <div id="15" class="con">
    <h2>Typescript</h2>
    TypeScript is a typed language, it is a superset of JavaScript. TypeScript simplifies JavaScript code, making it
    easier to read and debug. <br>
    Current version: 5.3.3


    <br>

  </div>


  <div id="16" class="con">
    <h2>Data binding in Angular</h2>
    Interpolation, Property binding, Class binding, Style binding, Attribute binding, Event binding, Two-way binding.

    <p>Types of Style binding<br>
      Style binding is used to set a style of a view element. There are 2 types of style bindings.
    </p>
    <ul>
      <li><u>Inline Style binding</u> eg: [style.width]="width"</li>
      <li><u>Expression style binding</u> eg: [style]="styleExpression" (Expression can be string or an object) <br>eg:
        {width: '100px', height: '100px', backgroundColor: 'cornflowerblue'}.
      </li>
    </ul>
  </div>


  <div id="17" class="con">
    <h2>This keyword</h2>
    <p>The <u>"this"</u> keyword always refers to an Object. The value of this always changes as per the scenarion in
      which it is called. </p>
    <p>Some different ways to use "this" keyword</p>
    <ul>
      <li>By itself -- Will refer window Object</li>
      <li>Inside Object method -- Will refer the owner object</li>
      <li>Inside function -- Will refer window object</li>
    </ul>
    <span class="cmd">If you use 'use strict' then you will get 'undefined', if there is no reference to 'this' keyword.
    </span>
    <br>

    <ul>
      <li></li>
      <li></li>
      <li></li>
      <li></li>
    </ul>
  </div>


  <div id="18" class="con">
    <h2>Call, Apply and Bind</h2>
    <h4>Call</h4>
    <p>Call, Apply and Bind are built-in pre-defined methods in JavaScript.</p>
    <p>Call is a function that helps you to chnage the context of the invoking function. In other words, it helps you
      replace the value of "this" inside a function with whatever value you want.</p>

    <p> call() method allows an object to use the method of another object.</p>
    <div class="code">
      const person1 = {<br>
      FName: "Raj",<br>
      LName: "Manchekar",<br>
      fullName: function (homeTown, country){<br>
      return this.FName +" "+ this.LName +" "+ this.homeTown +" "+ this.country;<br>
      }<br>
      }<br>
      <br>
      const person2 = {<br>
      FName: "Rhea",<br>
      LName: "Manchekar",<br>
      }<br>
      <br>

      console.log(person1.fullName.call(person2, "Pune", "India")) <span class="comment">//
        First argument is the Object which is borrowing, and second argument is a list of arguments to be passed to the
        method.</span>
      <br>
      <h4>Apply</h4>
      <u>Apply method is same as call method, only difference between the call method and apply method is that you pass
        the arguments as an array in apply.</u>
      <br><br>
      console.log(person1.fullName.apply(person2, ["Pune", "India"])) <span class="comment">Pass arguments in an
        Array</span>
      <br>
      <h4>Bind</h4>
      <p>Bind method creates a copy of a method that can be invoked later. Where as call method invokes instently.</p>

      const result = person1.fullName.bind(person2, "Pune", "India")

      console.log(result()) <span class="comment">// Output will be same as call method.</span>
    </div>
  </div>


  <div id="19" class="con">
    <h2>Map, Filter, Reduce</h2>
    <p>The Map() methods is used to create a new array from an existing array, applying a function to each element of
      the existing array. </p>

    <p>The Reduce() methods, reduces tahe array into a single value.</p>
    <div class="code">

    </div>
  </div>


  <div id="20" class="con">
    <h2>Closure</h2>
    <p>A closure gives you access to an outer function's scope from and inner function.</p>
    <p>A closure is the combination of a function bundled together with reference to it surrounding state.</p>

    <h4>Lexical Environment. Scope in JavaScript</h4>

    <b>Lexical scope</b> is the ability for a function scope to access variable from the parent scope.

    <p>We call the child function to be Lexical bound by that of the parent function.</p>





  </div>
  <div id="21" class="con">
    <h2>Promise</h2>
    <p>
      In JavaScript, a promise is an object representing the eventual completion or failure of an asynchronous
      operation.
      It allows you to handle asynchronous operations more cleanly and efficiently, avoiding deeply nested callback
      functions (known as "callback hell"). Promises have three states: pending, fulfilled, or rejected.
    </p>

    Eg.
    <div class="code">
      const promise1 = new Promise((resolve, reject) => {<br>
      setTimeout(() => {<br>
      resolve('foo');<br>
      }, 300);<br>
      });<br>
      <br>
      promise1.then((value) => {<br>
      console.log(value);<br>
      <span class="comment">// Expected output: "foo"</span><br>
      });<br>
      <br>
      console.log(promise1);<br>
      <br>
    </div>

    <h2>Promise.all()</h2>
    <p>Promise.all() is useful for aggregating the results of multiple promises. It will reject immediately upon any of
      the input promise is rejected</p>

    <h2>Promise.allSettled()</h2>
    <p>Promise.allSettled() is typically used when you have multiple asynchronous tasks that are not dependent on one
      another to complete successfully, or you'd always like to know the result of each promise.</p>

    <h2>Promise.any()</h2>
    <p>Promise.any() is useful for returning the first promise that fulfills. It does not wait for the other promises to
      complete once it finds one.</p>

    <h2>Promise.race()</h2>
    <p>Promise.race() is useful when you want the first async task to complete, but do not care about its eventual
      state.</p>
  </div>

  <div id="22" class="con">
    <h2>Optimize your web App</h2>
    <p>
      Debouncing and Throttling concepts are used for optimizing your web app. It happens by limiting the rate of
      execution of API calls.</p>
    Eg: The user types in the search bar to find a product and on every keystroke, we fire an event to fetch the
    data.<br>
    Debouncing is more used in e-commerce sites<br>
    <b>Debouncing</b>: If the difference between the two keystrokes is 300ms<br>
    <b>Throttling</b>: If the difference between the two function calls is 300ms. Calling an API after a certain
    interval of time.
  </div>

  <div id="23" class="con">
    <h2>View Encapsulation</h2>
    <p>
      The view encapsulation is a concept where the component's CSS styles are encapsulated into the components view and
      do not effect the rest of the application.</p>
  </div>

  <div id="24" class="con">
    <h2>View Child</h2>
    <ul>
      <li>In Javascript we use document.getElementById('con'), to get a reference of our HTML element, and then with DOM
        methods, we manipulate it.
      </li>
      <li>In Angular, if you want to get a reference of the element of your template file into the component class, in
        that case, you can use ViewChild or ViewChildern.
      </li>
      <li>If you need to access references of multiple components then use ViewChildren.</li>
    </ul>

  </div>

  <div id="25" class="con">
    <h2>Modules</h2>
    <p> Angular modules (NgModule) are containers for a group of related components, directives, pipes, and services.
      They help organize an application into cohesive blocks of functionality and enable lazy loading for better
      performance.</p>

  </div>

  <div id="26" class="con">
    <h2>Data Binding</h2>
    <p> Data binding in Angular allows you to synchronize the data between the component and the view. There are four
      types of data binding in Angular: interpolation, property binding, event binding, and two-way binding.</p>

    <ul>
      <li><b>Interpolation</b>: Interpolation is denoted by double curly braces ({{ }}). It allows you to render
        component data in the HTML template.</li>
      <li><b>Property Binding</b>: It allows you to set the value of an HTML element property by using square brackets
        [].</li>
      <li><b>Event Binding</b>: It allows you to listen to events raised by the user in the view, Eg: Click event</li>
      <li><b>Two-way Binding</b>: It combines property binding and event binding, allowing data to flow both ways
        between the component and the view. Two-way binding syntax is a combination of square brackets and parentheses
        [()].<br>
        Eg: app-sizer [(size)]="fontSizePx">/app-sizer>
      </li>
    </ul>

  </div>

  <div id="27" class="con">
    <h2>Routes</h2>
    <p>Angular's router is responsible for managing the application's navigation flow. Actually it allows you to
      navigate between different views (components) based on the URL. </p>

    <p><b>router-outlet</b> Angular will render the components corresponding to the current route.</p>

  </div>

</body>

</html>