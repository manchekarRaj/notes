<!DOCTYPE html>

<head>
  <link rel="stylesheet" href="./../notes_style.css">
  <style>
    body {
      font-family: 'Courier New', Courier, monospace;
      font-size: 17px;
      background-color: rgb(28, 28, 28);
      color: rgb(226, 234, 241);
    }

    .code {
      font-family: "Consolas";
      color: rgb(236, 255, 209);
      border: 1px;
      border-style: inset;
      width: 98%;
    }

    .con {
      background-color: black;
      border: 2px;
      border-style: double;
      padding: 3px;
      margin: 3px;
      width: 98%;

    }

    .comment {
      font-size: medium;
      font-style: italic;
      color: rgb(112, 111, 111);
    }

    h2 {
      color: rgb(72, 176, 245);
    }

    h4 {
      color: rgb(71, 144, 177);
      font-style: italic;
    }

    li {
      color: rgb(234, 225, 98);
    }

    u {
      color: rgb(0, 221, 203);
    }

    .cmd {
      color: rgb(124, 255, 141);
      font-family: 'Courier New', Courier, monospace;
    }

    b {
      color: rgb(255, 226, 61);
    }

    .keyword {
      color: rgb(93, 190, 255);
    }

    .class {
      color: rgb(255, 61, 77);
    }
  </style>

</head>

<body>
  <div id="1" class="con">
    <h2>Setup</h2>
    <p>Angular is a component-based framework for building scalable web applications.</p>
    <ul>
      <li>To install the Angular CLI > <span class="cmd">npm install -g @angular/cli</span></li>
      <li>Check Angular Version > <span class="cmd">ng version</span></li>
      <li>To create a new workspace > <span class="cmd">ng new my-app</span></li>
      <li>Run the application > <span class="cmd">ng serve</span></li>
      <li>Check TypeScript version > <span class="cmd">tsc -v</span></li>
    </ul>

    <b>Folder Structure:</b>
    <ul>
      <li>- TypeScript > The goal of typescript is to make JavaScript strongly typed, it give you object oriented
        feeling
        when you write code using typescript, and it increases productivity.</li>
      <li>- package.json > It has all the dependencies of Angular. You can also see the versions in which these
        angular dependencies are installed.</li>
      <li>- package-lock.json > It is a auto-generated file which locks down the versions of every insatlled packages,
        prevent unintended updates. '<b>package-lock.json</b>' is crucial for locking dependencies to specific versions,
        ensuring consistent installations across different environments. Without it, variations in installed versions
        may occur. This file guarantees reproducibility by specifying exact versions, preventing discrepancies.
        Including both `package.json` and `package-lock.json` in source control ensures that collaborators install the
        exact dependencies, maintaining uniformity. </li>
    </ul>
    <br>
    <p><b>Angular Flow:</b>
      First UI to run is the index.html, The Index.html call the main.ts, The main.ts calls the AppModule. Bootstrap in
      AppModule load the first component in the application, ie. the App.Component.ts, inside the selector, app-root in
      index.html.
    </p>

  </div>

  <div id="2" class="con">
    <h2>Components</h2>
    <p>Angular is a component-based framework for building scalable web applications. Components are the main building
      blocks for Angular applications. Each component consists of:</p>
    <ul>
      <li>- An HTML template that declares what renders on the page</li>
      <li>- A TypeScript class that defines behavior</li>
      <li>- A CSS selector that defines how the component is used in a template</li>
    </ul>
    <b>Generate component</b>
    <ul>
      <li><span class="cmd">ng generate component [name]</span></li>
    </ul>
    <p><b>Decorator</b><br>
      A decorator is a special kind of declaration that can be attached to classes, methods, accessors, properties, or
      parameters. Decorators are used to provide metadata about the element they decorate.
    </p>
    <p>Angular decorators typically start with the '@' symbol followed by the name of the decorator function. <br>
      For example, in Angular, @Component, @NgModule, @Directive, @Pipe, etc., are all decorators. They are used to
      annotate and configure various elements of an Angular application </p>
    <p><br>
    <ul>
      <li><u>@Component</u>: Decorates a class as an Angular component, providing metadata such as selector, template
        URL, style URLs, etc.</li>
      <li><u>@NgModule</u>: Decorates a class as an Angular module, providing metadata such as declarations, imports,
        providers, etc.</li>
      <li><u>@Directive</u>: Decorates a class as an Angular directive, providing metadata such as selector, inputs,
        outputs, etc.</li>
      <li><u>@Pipe</u>: Decorates a class as an Angular pipe, providing metadata such as name, pure, etc.</li>
    </ul>

    </p>
    <div class="code">
      <code class="!whitespace-pre hljs language-typescript">
      <span class="hljs-meta">@Component</span>({
      <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
      <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">'./app.component.html'</span>,
      <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">'./app.component.css'</span>]
      })
      </code>
    </div>

    <b>Component Lifecycle</b>
    <ul>
      <li>The component's lifecycle starts when Angular initializes the component, Then the component changes as per
        change detection, and the lifecycle ends when Angular destroys the component instance and removes its from the
        DOM.</li>
    </ul>
    <p>Component Lifecycle Hooks</p>
    <ul>
      <li><u>ngOnChanges</u> - When an input or output binding value changes.</li>
      <li><u>ngOnInit</u> - After the first ngOnChanges.</li>
      <li><u>ngDoCheck</u> - Developer's custom change detection.</li>
      <li><u>ngOnDestroy</u> - Just before the directive is destroyed.</li>
    </ul>
    <br>
    <p><u>Sharing data between child and parent directives and components</u></p>
    <ul>
      <li>- '@'Input() and Output() decorators give a child component a way to communicate with its parent component.
      </li>
      <li>- '@'Input() decorator, data flows from parent to child, To use Input() decorator, you must configure both
        parent and child.</li>
      <li>- '@'Output() decorator, the data flow from the child to the parent component.</li>
      <li>- Use EventEmitter class to while using '@'Output() decorator</li>
      <li>- <span class="cmd">'@'Output() newItemEvent = new EventEmitter<string>();</span></li>
      <li>- <span class="cmd">this.newItemEvent.emit(value);</span></li>
    </ul>

    <p>Use '@'Input() and '@'Output() on the same child component as follows:</p>
    <ul>
      <li><span class="cmd">child-component [item]="currentItem" (deleteRequest)="crossOffItem($event)"
          /child-component</span></li>
    </ul>

  </div>

  <div id="3" class="con">
    <h2>Templates</h2>
    <p>In Angular, a template is a blueprint for a fragment of a user interface (UI), written in HTML, and syntax</p>

    <p>Templates syntax</p>
    <ul>
      <li><u>Interpolation</u> - Uses the double curly braces <span class="cmd">{{ and }}</span> as delimiters.</li>
      <li><u>Property binding</u> - In property binding you set values for properties of HTML elements or directives.
      </li>
      <li>Eg, img tag: <span class="cmd">img alt="item" [src]="itemImageUrl"</span></li>
      <li><u>Event binding</u> - <span class="cmd">button (click)="onSave()" Save /button</span></li>
      <li><u>Attributes</u> - Provides additional information about that particular element. </li>
      <li>Attributes in HTML - src, alt, id, href, style, lang, width, height</li>
      <li><u>Class and style binding</u> - <span class="cmd">nav [style.background-color]="expression"/nav</span></li>
      <li><u>Two-way data binding</u> - <span class="cmd">app-sizer [(size)]="fontSizePx" app-sizer</span></li>
    </ul>
    <br>
  </div>

  <div id="4" class="con">
    <h2>Pipes</h2>
    <p>Pipes are used in the template expressions to transforme the values. </p>
    <ul>
      <li><u>DatePipe</u>: Formats a date value according to locale rules.</li>
      <li><u>CurrencyPipe</u>: Transforms a number to a currency string, formatted according to locale rules.</li>
      <li>LowerCasePipe , UpperCasePipe</li>
      <li><u>AsyncPipe</u>: Subscribe and unsubscribe to an asynchronous source such as an observable.</li>
      <li>The hero's birthday is {{ birthday | date }}</li>
      <li><u>Chained pipes</u>: The hero's birthday is {{ birthday | date | uppercase}}</li>
    </ul>
    <div class="code">
      import { Component } from '@angular/core';<br>
      import { DatePipe } from '@angular/common';<br>
      <br>
      '@'Component({<br>
      standalone: true,<br>
      selector: 'app-birthday',<br>
      templateUrl: './birthday.component.html',<br>
      imports: [DatePipe],<br>
      })<br><br>
      export class BirthdayComponent {<br>
      birthday = new Date(1988, 3, 15); // April 15, 1988 -- since month parameter is zero-based<br>
      }<br>
      <br>
    </div>
    <br>

    <h3>Custom Pipe</h3>

    <div class="code">

      <span class="keyword">import</span> { <span class="keyword">Pipe, PipeTransform</span> } <span
        class="keyword">from</span> '@angular/core';
      <br>
      '@'Pipe({<br>
      name: 'custom'<br>
      })<br>
      <span class="keyword">export class</span> <span class="class">CustomPipe</span> <span
        class="keyword">implements</span> <span class="class">PipeTransform</span> {<br>
      transform(value: any): any {<br>
      return value * 2;<br>
      }<br>
      }<br>

      <span class="comment">import and declare your custom pipe in app.module.ts</span>

      <div class="code">
        import { NgModule } from '@angular/core';<br>
        import { BrowserModule } from '@angular/platform-browser';<br>
        <span class="keyword">import</span> {<span class="class">CustomPipe</span>} <span class="keyword">from</span>
        './custom.pipe'; <span class="comment">// Import your custom pipe</span><br>
        <br>
        '@'NgModule({<br>
        declarations: [<br>
        CustomPipe <span class="comment">// Declare your custom pipe here</span><br>
        ],<br>
        imports: [<br>
        BrowserModule<br>
        ],<br>
        bootstrap: [],<br>
        })<br>
        export class AppModule { }<br>
      </div>



      </app>

    </div>
  </div>

  <div id="5" class="con">
    <h2>Directives</h2>
    <p>Directives are classes that add additional behavior to the elements in your Angular applications.</p>
    <ul>
      <li><b>Component Directives</b> - Components are directives with a template. They are the most common type of
        directive
        used in Angular applications. Components encapsulate HTML templates along with their associated logic into
        reusable, self-contained units. They are the building blocks of Angular applications and are used to create UI
        elements.</li>
      <li><b>Attribute directives</b> - Change the appearance or behavior of DOM elements<br>
        - <u>NgClass</u>: Adds and removes a set of CSS classes.<br>
        - <u>NgStyle</u>: Adds and removes a set of HTML styles.<br>
        - <u>NgModel</u>: Adds two-way data binding to an HTML form element.<br>
      </li>
      <li><b>Structural directives</b> - Change the DOM layout by adding and removing DOM elements.<br>
        - <u>NgIf</u>: Adds and removes a set of CSS classes.<br>
        - <u>NgFor</u>: Adds and removes a set of HTML styles.<br>
      </li>
    </ul>

    <p>Here's an example of an attribute directive that changes the background color of an element based on a condition:
    </p>
    <div class="code">
      <code class="!whitespace-pre hljs language-typescript">
      <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Directive</span>, <span class="hljs-title class_">ElementRef</span>, <span class="hljs-title class_">Input</span>, <span class="hljs-title class_">Renderer2</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

      <span class="hljs-meta">@Directive</span>({
        <span class="hljs-attr">selector</span>: <span class="hljs-string">'[appHighlight]'</span>
      })
      <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HighlightDirective</span> {
        <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> el: ElementRef, <span class="hljs-keyword">private</span> renderer: Renderer2</span>) {}
        
        <span class="hljs-meta">@Input</span>(<span class="hljs-string">'appHighlight'</span>) <span class="hljs-attr">highlightColor</span>: <span class="hljs-built_in">string</span>;
        
        <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">highlight</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">highlightColor</span> || <span class="hljs-string">'yellow'</span>);
        }
        
        <span class="hljs-keyword">private</span> <span class="hljs-title function_">highlight</span>(<span class="hljs-params">color: <span class="hljs-built_in">string</span></span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderer</span>.<span class="hljs-title function_">setStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>.<span class="hljs-property">nativeElement</span>, <span class="hljs-string">'backgroundColor'</span>, color);
        }
      }
    </code>
    </div>
    <p>And here's how you would use this directive in your HTML template:</p>
    <div class="code">
      <code class="!whitespace-pre hljs language-html">
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">appHighlight</span> [<span class="hljs-attr">highlightColor</span>]=<span class="hljs-string">"'lightblue'"</span>&gt;</span>Highlighted text<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    </code>
    </div>
    <p>In this example, the "<u>appHighlight</u>" directive changes the background color of the div element to light
      blue.</p>

  </div>

  <div id="6" class="con">
    <h2>Dependency Injection</h2>
    <p>When you develop a smaller part of your system, like a module or a class, you may need to use features from other
      classes. For example, you may need an HTTP service to make backend calls. Dependency Injection, or DI, is a design
      pattern and mechanism for creating and delivering some parts of an application to other parts of an application
      that require them. Angular supports this design pattern and you can use it in your applications to increase
      flexibility and modularity.</p>
    <ul>
      <li>'@'Injectable() - The first step is to add the @Injectable decorator to show that the class can be injected.
      </li>
      <li>constructor(private service: HeroService) {} - The most common way to inject a dependency is to declare it in
        a class constructor.</li>
    </ul>
    <p>Hierarchical injectors</p>
    <ul>
      <li>In Hierarchical injectors, you can determine whether to declare a provider at the application level, in a
        Component, or in a Directive</li>
    </ul>

  </div>

  <div id="7" class="con">
    <h2>Best Practices</h2>
    <ul>
      <li><u>Security</u>: Security against cross-site scripting attacks</li>
      <li><u>Accessibility</u>: For people with visual or motor impairements</li>
      <li><u>Keeping up-to-date</u>: To optamize your application there is one way you can do is to keep your
        application
        up-to-date</li>
      <li><u>Property binding best practices</u>: Avoid side effects?????
      </li>
      <li><u>Lazy-loading</u>: By default, NgModules are eagerly loaded. So for large applications with lots of routes,
        we can
        consider using lazy loading, this will help to keep the application (bundle) size small, which in turn helps
        decrease load times.</li>
      <li><u>Lightweight injection token pattern for libraries</u>: The lightweight injection token design pattern is
        especially important for library developers. It ensures that when an application uses only some of your
        library's capabilities, the unused code can be eliminated from the client's application bundle???????</li>
    </ul>

    <p>
      Cross-site scripting (XSS) enables attackers to inject malicious code into web pages and then they can steal your
      sensative data like login username/password or perform actions that impersonate the user.<br>
      To block XSS attacks, you must prevent malicious code from entering the Document Object Model (DOM).<br>
      Eg: <span class="cmd"> img alt="" onerror="..."> and a> href="javascript:..."/a> </span>.

    </p>

    <h2>Security Best Practices</h2>
    Most of the time older versions are not maintained, so it's better to migrate to the latest version.<br>
    <br>
    If you are dealing with sensitive data, it is better to use SSL, This technology encrypts data before it is sent
    from the client to the server, thus preventing some common hacks like packet sniffing. TLS is the next level of SSL.
    <br><br>
    Packet sniffing is the process of intercepting the data stream that flows across the network, you can capture each
    packet and, if needed, decode the packet's raw data. This way you can get access to the raw value.
    <br><br>
    You can use Helmet. Helmet helps protect your application by setting HTTP headers appropriately.
    <br><br>
    <ul>
      <li>Content-Security-Policy header. This helps prevent cross-site scripting attacks.</li>
      <li>X-Frame-Options header. This provides clickjacking protection.</li>
      <li> Strict-Transport-Security header. This helps enforce secure (HTTPS) connections to the server.</li>
    </ul>
    <br>

    <b>Clickjacking</b> - When an attacker uses multiple transparent or opaque layers to trick a user into clicking on a
    button
    or link on another page.
    <br><br>
    Helmet is a collection of smaller middleware functions that set security-related HTTP response headers.
    <br><br>
    Security best practices for Express applications in production include:
    <ul>
      <li>Don't use deprecated or vulnerable versions of Express</li>
      <li>Use TLS (Transport Layer Security)</li>
      <li>Use Helmet</li>
      <li>Use cookies securely</li>
      <li>Prevent brute-force attacks against authorization</li>
      <li>Ensure your dependencies are secure</li>
      <li>Avoid other known vulnerabilities</li>
    </ul>


  </div>

  <div id="8" class="con">
    <h2>Interceptor</h2>
    <p>The http Interceptor basically intercepts the outgoing HTTP requests, transforms them and then sends it to the
      server. The Interceptor modifies the request to contain the token that is stored in the browser’s local storage.
    </p>
  </div>


  <div id="9" class="con">
    <h2>Route Guard</h2>
    <p>
      Route guards control the navigation to and from components, it can return true in which case the normal execution
      continues or returns false in which case the navigation is stopped. For routes which needs authentication the
      route guard will return true if the token is present in the browser and return false if the token is absent.<br>

      Just the existence of the token is not important, the token has to be verified through the backend to make sure it
      is valid. To achieve that we can use Angular Interceptor

    </p>
    <div class="code">

    </div>

  </div>

  <div id="10" class="con">
    <h2>Observables & RxJS</h2>
    Observables are used to pass values/data across your application. They are used frequently in Angular and are a
    technique for event handling, asynchronous programming, and handling multiple values.
    <br>

    <b>NOTIFICATION TYPE</b><br>
    <u>next</u>: Required. A handler for each delivered value. Called zero or more times after execution starts.<br>
    <u>error</u>: Optional. A handler for an error notification. An error halts execution of the observable
    instance.<br>
    <u>complete</u>: Optional. A handler for the execution-complete notification. Delayed values can continue to be
    delivered to the next handler after execution is complete.<br>
    For Error handling you use error callbacks on the observer.<br><br>
    <span class="cmd">
      myObservable.subscribe({<br>
      next(num) { console.log('Next num: ' + num)},<br>
      error(err) { console.log('Received an error: ' + err)}<br>
      });<br>
    </span>
    <br>

  </div>

  <div id="11" class="con">
    <h2>Lifecycle hooks</h2>
    <p>An Angular Component goes through different phases right from its creation until it is destroyed.</p>
    <uL>
      <li><u>constructor</u> : This is invoked when Angular creates a component or directive by calling new on the
        class.</li>
      <li><u>ngOnChanges</u>: Invoked every time there is a change in one of the input properties of the component.</li>
      <li><u>ngOnInit</u> : Invoked when a given component has been initialized.
        This hook is only called once after the first ngOnChanges
      </li>
      <li><u>ngDoCheck</u>: Invoked when the change detector of the given component is invoked. It allows us to
        implement our
        own change detection algorithm for the given component.
        Use ngDoCheck when you want to capture changes that Angular otherwise doesn't. For example, if a binding
        reference remains unchanged after a click event, ngOnChanges won't run but ngDoCheck will.
      </li>
      <li><u>ngOnDestroy</u>:This method will be invoked just before Angular destroys the component. Use this hook to
        unsubscribe
        observables and detach event handlers to avoid memory leaks.</li>
      <li><u>ngAfterViewChecked</u>: ngAfterViewChecked is useful when you want to call a lifecycle hook after all child
        components have been initialized and checked.</li>
      <li><u>ngAfterViewInit</u>: If you need to access the child component after it's initialized, you can use the
        ngAfterViewInit lifecycle hook. This ensures that the child component is available for interaction. (Refer,
        @ViewChild).</li>
    </ul>
  </div>

  <div id="12" class="con">
    <h2>Async Pipe</h2>
    <ul>
      <li>The async pipe returns the latest value from a stream of data and continues to do so for the life of a given
        component. When Angular destroys that component, the async pipe automatically stops.</li>
      <li>We are directly using the Observables with the async pipe on the template.</li>
      <li>With an async pipe you can handle asynchronous data in an Angular template.</li>
      <li>Any time you subscribe to an Observable, you need to unsubscribe, otherwise your code would leak and you might
        face unexpected behavior in your application.</li>
      <li>Async pipe handles unsubscription for you.</li>
      <li>The async pipe will trigger change detection when a new value is emitted.</li>
    </ul>

    <span class="cmd">
      {{ greeting | async }} // in template

    </span>
  </div>
  <div id="13" class="con">
    <h2>ViewChild Decorator</h2>
    <uL>
      <li>In Javascript we use document.getElementById('con'), to get a reference of our HTML element, and then with DOM
        methods, we manipulate it.</li>
      <li>In Angular, if you want to get a reference of the element of your template file into the component class, in
        that case, you can use ViewChild or ViewChildern.</li>
      <li>If you need to access references of multiple components then use ViewChildren.</li>
    </uL>

    <span class="cmd">
      // In template <br>
      pane id="1" '*'ngIf="shouldShow">/pane><br>
      pane id="2" '*'ngIf="'!'shouldShow">/pane><br>

      <br>
      // In component <br>
      '@'ViewChild(Pane) <br>
      set pane(v: Pane) { <br>
      setTimeout(() => { <br>
      this.selectedPane = v.id; <br>
      }, 0); <br>
      } <br>



    </span>


  </div>
  <div id="14" class="con">
    <h2>Template variables / Symbol</h2>
    Template variables are used to refer to an HTML element and all of its DOM properties. You use the # symbol followed
    by the variable name.<br>
    <span class="cmd">
      input #myInput type=”text”><br>
      button (click)=”logMessage(myInput.value)”> /button><br>
    </span>
    <p><u>Template variable scope</u>: Refer to a template variable anywhere within its surrounding template. Structural
      directives, such as *ngIf and *ngFor, or /ng-template> act as a template boundary. You cannot access template
      variables outside of these boundaries.
    </p>
  </div>

  <div id="15" class="con">
    <h2>Typescript</h2>
    TypeScript is a typed language, it is a superset of JavaScript. TypeScript simplifies JavaScript code, making it
    easier to read and debug. <br>
    Current version: 5.3.3
    <br>
  </div>

  <div id="16" class="con">
    <h2>...</h2>
  </div>

  <div id="17" class="con">
    <h2>This keyword</h2>
    <p>The <u>"this"</u> keyword always refers to an Object. The value of this always changes as per the scenarion in
      which it is called. </p>
    <p>Some different ways to use "this" keyword</p>
    <ul>
      <li>By itself -- Will refer window Object</li>
      <li>Inside Object method -- Will refer the owner object</li>
      <li>Inside function -- Will refer window object</li>
    </ul>
    <span class="cmd">If you use 'use strict' then you will get 'undefined', if there is no reference to 'this' keyword.
    </span>
    <br>

    <ul>
      <li></li>
      <li></li>
      <li></li>
      <li></li>
    </ul>
  </div>


  <div id="18" class="con">
    <h2>Call, Apply and Bind</h2>
    <h4>Call</h4>
    <p>Call, Apply and Bind are built-in pre-defined methods in JavaScript.</p>
    <p>Call is a function that helps you to chnage the context of the invoking function. In other words, it helps you
      replace the value of "this" inside a function with whatever value you want.</p>

    <p> call() method allows an object to use the method of another object.</p>
    <div class="code">
      const person1 = {<br>
      FName: "Raj",<br>
      LName: "Manchekar",<br>
      fullName: function (homeTown, country){<br>
      return this.FName +" "+ this.LName +" "+ this.homeTown +" "+ this.country;<br>
      }<br>
      }<br>
      <br>
      const person2 = {<br>
      FName: "Rhea",<br>
      LName: "Manchekar",<br>
      }<br>
      <br>

      console.log(person1.fullName.call(person2, "Pune", "India")) <span class="comment">//
        First argument is the Object which is borrowing, and second argument is a list of arguments to be passed to the
        method.</span>
      <br>
      <h4>Apply</h4>
      <u>Apply method is same as call method, only difference between the call method and apply method is that you pass
        the arguments as an array in apply.</u>
      <br><br>
      console.log(person1.fullName.apply(person2, ["Pune", "India"])) <span class="comment">Pass arguments in an
        Array</span>
      <br>
      <h4>Bind</h4>
      <p>Bind method creates a copy of a method that can be invoked later. Where as call method invokes instently.</p>

      const result = person1.fullName.bind(person2, "Pune", "India")

      console.log(result()) <span class="comment">// Output will be same as call method.</span>
    </div>
  </div>


  <div id="19" class="con">
    <h2>Map, Filter, Reduce</h2>
    <p>The Map() methods is used to create a new array from an existing array, applying a function to each element of
      the existing array. </p>

    <p>The Reduce() methods, reduces tahe array into a single value.</p>
    <div class="code">

    </div>
  </div>


  <div id="20" class="con">
    <h2>Closure</h2>
    <p>A closure gives you access to an outer function's scope from and inner function.</p>
    <p>A closure is the combination of a function bundled together with reference to it surrounding state.</p>

    <h4>Lexical Environment. Scope in JavaScript</h4>

    <b>Lexical scope</b> is the ability for a function scope to access variable from the parent scope.

    <p>We call the child function to be Lexical bound by that of the parent function.</p>





  </div>
  <div id="21" class="con">
    <h2>Promise</h2>
    <p>
      Promise in JavaScript is object which represents the eventual completion (or failure) of an asynchronous
      operations.
      A Promise take two parameters: 'resolve' and 'reject'.
    </p>

    Eg.
    <div class="code">
      const promise1 = new Promise((resolve, reject) => {<br>
      setTimeout(() => {<br>
      resolve('foo');<br>
      }, 300);<br>
      });<br>
      <br>
      promise1.then((value) => {<br>
      console.log(value);<br>
      <span class="comment">// Expected output: "foo"</span><br>
      });<br>
      <br>
      console.log(promise1);<br>
      <br>
    </div>

    <h2>Promise.all()</h2>
    <p>Promise.all() is useful for aggregating the results of multiple promises. It will reject immediately upon any of
      the input promise is rejected</p>

    <h2>Promise.allSettled()</h2>
    <p>Promise.allSettled() is typically used when you have multiple asynchronous tasks that are not dependent on one
      another to complete successfully, or you'd always like to know the result of each promise.</p>

    <h2>Promise.any()</h2>
    <p>Promise.any() is useful for returning the first promise that fulfills. It does not wait for the other promises to
      complete once it finds one.</p>

    <h2>Promise.race()</h2>
    <p>Promise.race() is useful when you want the first async task to complete, but do not care about its eventual
      state.</p>

    <h2>Async-Await</h2>
    <p>Async-Await is a new JavaScript feature that allows you to write asynchronous code in a synchronous-like
      manner. It's provides cleaner and readable syntax for handling asynchronous operations.</p>

    <div class="code">
      <span class="keyword">async</span> <span class="fn">function</span> fetchData() {<br>
      try {<br>
      const data = <span class="keyword">await</span> fetchDataFromAPI(); <span class="comment">// fetchDataFromAPI()
        returns a promise</span><br>
      console.log(data);<br>
      } catch (error) {<br>
      console.error(error); <span class="comment">// Handle error</span><br>
      }<br>
      }<br>

      <br>
      <span class="fn">fetchData</span>()<br>
      . <span class="fn">then</span>((_data) => console.log('Data fetched successfully', _data))<br>
      . <span class="fn">catch</span>((error) => console.error('Failed to fetch data:', error));<br>
    </div>

    <div id="22" class="con">
      <h2>Optimize your web App</h2>
      <p>
        Debouncing and Throttling concepts are used for optimizing your web app. It happens by limiting the rate of
        execution of API calls.</p>
      Eg: The user types in the search bar to find a product and on every keystroke, we fire an event to fetch the
      data.<br>
      Debouncing is more used in e-commerce sites<br>
      <b>Debouncing</b>: If the difference between the two keystrokes is 300ms<br>
      <b>Throttling</b>: If the difference between the two function calls is 300ms. Calling an API after a certain
      interval of time.
    </div>

    <div id="23" class="con">
      <h2>View Encapsulation</h2>
      <p>
        The view encapsulation is a concept where the component's CSS styles are encapsulated into the components view
        and
        do not effect the rest of the application.</p>
    </div>

    <div id="24" class="con">
      <h2>View Child</h2>
      <p>
        In Angular, @ViewChild is a decorator used to access child components, directives, or elements within a parent
        component. It allows the parent component to query and interact with its child components programmatically.<br>
        @ViewChild is particularly useful when you need to access properties or methods of child components from the
        parent component.</p>

      <p>Here's how @ViewChild works:</p>
      <p>1. <b>Import ViewChild</b> :First, import ViewChild from @angular/core in your parent component file.</p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
        <span class="hljs-keyword">import</span> { <span class="hljs-title class_">ViewChild</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
      </code>
      </div>

      <p>2. <b>Decorate the Property</b>: Next, decorate a property in the parent component with @ViewChild. </p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
        <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span>, <span class="hljs-title class_">ViewChild</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
        <span class="hljs-keyword">import</span> { <span class="hljs-title class_">ChildComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./child.component'</span>;
          
        <span class="hljs-meta">@Component</span>({
          <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-parent'</span>,
          <span class="hljs-attr">template</span>: <span class="hljs-string">`
            &lt;app-child&gt;&lt;/app-child&gt;
          `</span>
        })
        <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentComponent</span> {
          <span class="hljs-meta">@ViewChild</span>(<span class="hljs-title class_">ChildComponent</span>) <span class="hljs-attr">childComponent</span>: <span class="hljs-title class_">ChildComponent</span>;
        }
        </code>
      </div>
      <p>3. <b>Access Child Properties and Methods</b>: Now, you can access properties and methods of the child
        component through the childComponent property in the parent component.</p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
        <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

        <span class="hljs-meta">@Component</span>({
          <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-child'</span>,
          <span class="hljs-attr">template</span>: <span class="hljs-string">`
            &lt;p&gt;Child Component&lt;/p&gt;
          `</span>
        })
        <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildComponent</span> {
          <span class="hljs-attr">childProperty</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">'Hello from child'</span>;
          
          <span class="hljs-title function_">childMethod</span>(<span class="hljs-params"></span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Method called from child'</span>);
          }
        }
        </code>
      </div>
      <p>In the parent component:</p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
        <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentComponent</span> {
        <span class="hljs-meta">@ViewChild</span>(<span class="hljs-title class_">ChildComponent</span>) <span class="hljs-attr">childComponent</span>: <span class="hljs-title class_">ChildComponent</span>;
        
        <span class="hljs-title function_">ngAfterViewInit</span>(<span class="hljs-params"></span>) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">childComponent</span>.<span class="hljs-property">childProperty</span>); <span class="hljs-comment">// Output: Hello from child</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">childComponent</span>.<span class="hljs-title function_">childMethod</span>(); <span class="hljs-comment">// Output: Method called from child</span>
        }
      }
      </code>
      </div>
      <p>4. <b>Lifecycle Hook</b>: If you need to access the child component after it's initialized, you can use the
        "<u>ngAfterViewInit</u>" lifecycle hook. This ensures that the child component is available for interaction.</p>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
        <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentComponent</span> {
        <span class="hljs-meta">@ViewChild</span>(<span class="hljs-title class_">ChildComponent</span>) <span class="hljs-attr">childComponent</span>: <span class="hljs-title class_">ChildComponent</span>;
          
        <span class="hljs-title function_">ngAfterViewInit</span>(<span class="hljs-params"></span>) {
          <span class="hljs-comment">// Access child component here</span>
        }
      }
      </code>
      </div>
      <br>
      <p>"@ViewChild" allows you to establish communication between parent and child components in Angular, enabling you
        to build more dynamic and interactive applications.</p>






    </div>

    <div id="25" class="con">
      <h2>Modules</h2>
      <p> Angular modules (NgModule) are containers for a group of related components, directives, pipes, and services.
        They help organize an application into cohesive blocks of functionality. Modules help to keep the codebase
        organized, maintainable, and scalable by promoting modularity and encapsulation.</p>
      <br>
      <p>Angular applications typically have at least one root module, called the AppModule, which serves as the entry
        point for the application. Additionally, Angular applications can have multiple feature modules, each focusing
        on a specific feature or aspect of the application.</p>
      <br>
      <p>Key concepts related to Angular modules:</p>
      <ul>
        <li><b>NgModule Decorator</b>: Modules are defined using the @NgModule decorator. This decorator provides
          metadata about the module, such as its declarations, imports, exports, and providers.</li>
        <li><b>Declarations</b>: Components, directives, and pipes that belong to the module are listed here in
          Declarations.</li>
        <li><b>Imports</b>: Imports specify other modules whose exported members should be available within the current
          module. This allows you to reuse functionality from other modules.</li>
        <li><b>Exports</b>: Exports specify which declarations of the module should be accessible to other modules that
          import it.</li>
        <li><b>Providers</b>: Providers are used to register services within the module. Services provided at the module
          level are typically singletons, meaning there is only one instance of the service throughout the application.
        </li>
      </ul>
      <div class="code">
        <code class="!whitespace-pre hljs language-typescript">
        <span class="hljs-keyword">import</span> { <span class="hljs-title class_">NgModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
        <span class="hljs-keyword">import</span> { <span class="hljs-title class_">BrowserModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;
        <span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.component'</span>;
          
        <span class="hljs-meta">@NgModule</span>({
          <span class="hljs-attr">declarations</span>: [
            <span class="hljs-title class_">AppComponent</span>
          ],
          <span class="hljs-attr">imports</span>: [
            <span class="hljs-title class_">BrowserModule</span>
          ],
          <span class="hljs-attr">providers</span>: [],
          <span class="hljs-attr">bootstrap</span>: [<span class="hljs-title class_">AppComponent</span>]
        })
        <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> { }
        </code>
      </div>
      <p>In this example, AppModule is the root module of the application. It declares the AppComponent and imports the
        BrowserModule, which is required for running the application in a web browser. The bootstrap property specifies
        the root component of the application.</p>
    </div>

    <div id="26" class="con">
      <h2>Data Binding</h2>
      <p> Data binding in Angular allows you to synchronize the data between the component and the view. There are four
        types of data binding in Angular: interpolation, property binding, event binding, and two-way binding.</p>

      <ul>
        <li><b>Interpolation</b>: Interpolation is denoted by double curly braces ({{ }}). It allows you to render
          component data in the HTML template.
          <div class="code">
            <code class="!whitespace-pre hljs language-html">
            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{{ title }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
            </code>
          </div>
        </li>
        <li><b>Property Binding</b>: It allows you to set the value of an HTML element property by using square brackets
          [].

          <div class="code">
            <code class="!whitespace-pre hljs language-html">
            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"imageUrl"</span>&gt;</span>
          </code>
          </div>
        </li>
        <li><b>Event Binding</b>: It allows you to listen to events raised by the user in the view, Eg: Click event.
          <div class="code">
            <code class="!whitespace-pre hljs language-html">
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"onButtonClick()"</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          </code>
          </div>
        </li>
        <li><b>Two-way Binding</b>: It combines property binding and event binding, allowing data to flow both ways
          between the component and the view. Two-way binding syntax is a combination of square brackets and parentheses
          [()].
          <div class="code">
            <code class="!whitespace-pre hljs language-html">
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"name"</span>&gt;</span>
            </code>

          </div>
          <br>
          Eg: app-sizer [(size)]="fontSizePx">/app-sizer>
        </li>
        <li>
          <b>Attribute Binding</b>: Attribute binding allows you to dynamically set an element's attribute value based
          on the component's data. It is denoted by the attr. prefix.
          <div class="code">
            <code class="!whitespace-pre hljs language-html">
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">attr.role</span>]=<span class="hljs-string">"isAdmin ? 'admin' : 'user'"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          </code>
          </div>
        </li>
        <li>
          <b>Class Binding</b>: Class binding allows you to add or remove CSS classes dynamically based on the
          component's data. It is denoted by the class. prefix.
          <div class="code">
            <code class="!whitespace-pre hljs language-html">
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">class.error</span>]=<span class="hljs-string">"isError"</span>&gt;</span>Error message<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            </code>
          </div>
        </li>
      </ul>

    </div>

    <div id="27" class="con">
      <h2>Routes</h2>
      <p>Angular's router is responsible for managing the application's navigation flow. Actually it allows you to
        navigate between different views (components) based on the URL. </p>
      <p><b>router-outlet</b> Angular will render the components corresponding to the current route.</p>
    </div>

    <div id="28" class="con">
      <h2>Hoisting</h2>
      <p>Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their
        containing scope during the compile phase before the code execution. This means that regardless of where
        variables and functions are declared within their scope, they are treated as if they were declared at the top.
        However, only the declarations are hoisted, not the initializations or assignments.</p>
    </div>

    <div id="29" class="con">
      <h2>Loops</h2>
      <ul>
        <li>for - loops through a block of code a number of times</li>
        <li>for/in - loops through the properties of an object</li>
        <li>for/of - loops through the values of an iterable object</li>
        <li>while - loops through a block of code while a specified condition is true</li>
        <li>do/while - also loops through a block of code while a specified condition is true</li>
      </ul>

      <b>while loop</b>
      <div class="code">
        let i = 0;<br>
        while (i'<'5) { <br>
          console.log(i); <span class="comment">// Output: 0, 1, 2, 3, 4</span> <br>
          i++; <br>
          }
      </div>

      <b>'do-while' Loop</b>
      <div class="code">
        let i = 0;<br>
        do {<br>
        console.log(i); <span class="comment">// Output: 0, 1, 2, 3, 4</span> <br>
        i++;<br>
        } while (i '<' 5); </div>


          <b>'for...of' Loop</b>
          <div class="code">
            const numbers = [1, 2, 3, 4, 5];<br>
            for (const num of numbers) {<br>
            console.log(num); <span class="comment">// Output: 0, 1, 2, 3, 4, 5</span><br>
            }<br>
          </div>
      </div>

      <div id="30" class="con">
        <h2>Tricky Questions</h2>
        <ul>
          <li>Number(" 123 ") // 123</li>
          <li>Number("123z") // NaN (error reading a number at "z") </li>
          <li>Number(true) // 1</li>
          <li>Number(false) // 0</li>
          <li>Boolean(1) // true</li>
          <li>Boolean(0) // false</li>
          <li>Boolean("hello") // true</li>
          <li>Boolean("") // false</li>
          <li>Boolean("0") // true</li>
          <li>Boolean(" ") // true </li>
          <li>6 - '2' // 4</li>
          <li>'6' / '2' // 3</li>
          <li>let a = 1, b = 1;<br>
            let c = ++a;<br>
            let d = b++;<br>
            console.log(c, d, b) // 2 1 2
          </li>
          <li>"" + 1 + 0 = "10" // The addition with a string "" + 1 converts 1 to a string: "" + 1 = "1", and then we
            have "1" + 0, the same rule is applied.</li>
          <li>"" - 1 + 0 = -1 // The subtraction - (like most math operations) only works with numbers, it converts an
            empty string "" to 0.</li>
          <li>true + false = 1</li>
          <li>6 / "3" = 2</li>
          <li>"2" * "3" = 6</li>
          <li>4 + 5 + "px" = "9px"</li>
          <li>"$" + 4 + 5 = "$45"</li>
          <li>"4" - 2 = 2</li>
          <li>"4px" - 2 = NaN</li>
          <li>" -9 " + 5 = " -9 5" // The addition with a string appends the number 5 to the string.</li>
          <li>" -9 " - 5 = -14 // The subtraction always converts to numbers, so it makes " -9 " a number -9</li>
          <li>null + 1 = 1 // null becomes 0 after the numeric conversion.</li>
          <li>undefined + 1 = NaN // undefined becomes NaN after the numeric conversion.</li>
          <li>" \t \n" - 2 = -2 // Space characters are trimmed off string start and end when a string is converted to a
            number. Here the whole string consists of space characters, such as \t, \n and a “regular” space between
            them. So, similarly to an empty string, it becomes 0.</li>
        </ul>



      </div>

</body>

</html>